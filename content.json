{"meta":{"title":"Yan's Blog","subtitle":"","description":"","author":"OVYVO","url":"https://ovyvo.github.io/yanblog.github.io","root":"/yanblog.github.io/"},"pages":[{"title":"关于","date":"2024-02-27T04:11:39.222Z","updated":"2024-02-27T04:11:39.222Z","comments":false,"path":"about/index.html","permalink":"https://ovyvo.github.io/yanblog.github.io/about/index.html","excerpt":"","text":"沪漂前端攻城狮 123456789101112131415161718192021&#123; name: &#x27;若拙&#x27; age: 26, gender: &#x27;男&#x27;, profession: &#x27;Web Developer&#x27;, experience: &#x27;4.5&#x27;, address: &#x27;上海市普陀区&#x27;, education: &#x27;本科&#x27;, github: &#x27;https://github.com/OVYVO&#x27;, email: &#x27;vue12306@163.com&#x27;, description: &#x27;大瓢贮月归春瓮，小杓分江入夜瓶&#x27;, skills: [ [&#x27;Html&#x27;, &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;, &#x27;ES6&#x27;], [&#x27;Vue&#x27;,&#x27;Nuxt&#x27;,&#x27;Taro&#x27;,&#x27;React&#x27;], [&#x27;AntDesign&#x27;, &#x27;Element&#x27;, &#x27;Vant&#x27;], [&#x27;Webpack&#x27;, &#x27;Gulp&#x27;, &#x27;Vite&#x27;], [&#x27;CSS&#x27;,&#x27;Less&#x27;,&#x27;Sass&#x27;], [&#x27;Git&#x27;,&#x27;Node&#x27;] ]&#125;"},{"title":"书单","date":"2022-07-31T11:43:24.895Z","updated":"2022-07-31T11:43:24.895Z","comments":false,"path":"books/index.html","permalink":"https://ovyvo.github.io/yanblog.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-31T11:43:24.895Z","updated":"2022-07-31T11:43:24.895Z","comments":false,"path":"categories/index.html","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-27T04:13:15.828Z","updated":"2022-11-27T04:13:15.828Z","comments":false,"path":"links/index.html","permalink":"https://ovyvo.github.io/yanblog.github.io/links/index.html","excerpt":"","text":""},{"title":"个人项目","date":"2022-07-31T11:43:24.895Z","updated":"2022-07-31T11:43:24.895Z","comments":false,"path":"repository/index.html","permalink":"https://ovyvo.github.io/yanblog.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-31T11:43:24.896Z","updated":"2022-07-31T11:43:24.896Z","comments":false,"path":"tags/index.html","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Nginx基本概念及使用方式","slug":"blog27","date":"2023-12-07T16:00:00.000Z","updated":"2024-01-05T05:58:54.238Z","comments":false,"path":"2023/12/08/blog27/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/12/08/blog27/","excerpt":"","text":"Nginx相关概念 简单请求与非简单请求 请求方法是HEAD、GET、POST三种之一，并且HTTP头信息限于Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type（限于application/x-www-form-urlencoded、multipart/form-data、text/plain）即为简单请求，其余皆为非简单请求。简单请求与非简单请求区别体现在服务器对请求响应的预处理以及请求信息设置还有返回信息的处理上，不详细表述，可自行查阅相关文档。 跨域开发几乎都知道，不详细表述 123456789101112131415161718//同源的例子http://example.com/app1/index.html //只是路径不同http://example.com/app2/index.htmlhttp://Example.com:80 //只是大小写差异http://example.com//不同源的例子http://example.com/app1 //协议不同https://example.com/app2http://example.com //host 不同http://www.example.comhttp://myapp.example.comhttp://example.com //端口不同http://example.com:8080 正向代理与反向代理正向代理：客户端-&gt;代理服务器-&gt;目标服务器，客户端向代理服务器发送请求指定目标服务器，由代理服务器与目标服务器进行数据交换，再又代理服务器将数据返回给客户端。理解：翻墙工具反向代理：客户端-&gt;代理服务器-&gt;服务器集群，客户端发送请求给代理服务器，代理服务器将请求再分发给服务器集群，具体哪个服务器处理信息不知道，使得真实处理的服务器对客户端不可见。理解：商店买东西，明确买什么商品，商店采购，商店扮演的就是反向服务器角色。 负载均衡请求并发不多的情况下，服务器能够正常响应所有的请求，网络响应快速。当并发量上来了之后，单一的服务器不能同时处理太多的请求。此时只能将服务器性能提高。或者采用负载均衡的做法，简单理解就是，使用多台服务器形成一个服务器集群，当大规模的请求来临的时候，由Nginx充当协调员角色，将请求分发到不同的服务器去处理并返回响应。 动静分离将服务器上的静态资源与动态资源分离。根据不同的请求类型请求对应的资源，还可以利用nginx缓存的优势更快的响应资源请求。 Nginx操作常用命令123456nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启nginx -s reopen # 重启 Nginxnginx -s stop # 快速关闭nginx -s quit # 等待工作进程处理完成后关闭nginx -T # 查看当前 Nginx 最终的配置nginx -t -c &lt;配置路径&gt; # 检查配置是否有问题，如果已经在配置目录，则不需要-c Nginx配置 主配置文件/etc/nginx/nginx.conf nginx.config结构图: 1234567891011main # 全局配置，对全局生效├── events # 配置影响 Nginx 服务器或与用户的网络连接├── http # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置│ ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分│ ├── server # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块│ ├── server│ │ ├── location # server 块可以包含多个 location 块，location 指令用于匹配 uri│ │ ├── location│ │ └── ...│ └── ...└── ... 配置实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445user nginx; # 运行用户，默认即是nginx，可以不进行设置worker_processes 1; # Nginx 进程数，一般设置为和 CPU 核数一样error_log /var/log/nginx/error.log warn; # Nginx 的错误日志存放目录pid /var/run/nginx.pid; # Nginx 服务启动时的 pid 存放位置events &#123; use epoll; # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的) worker_connections 1024; # 每个进程允许最大并发数&#125;http &#123; # 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置 # 设置日志模式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; # Nginx访问日志存放位置 sendfile on; # 开启高效传输模式 tcp_nopush on; # 减少网络报文段的数量 tcp_nodelay on; keepalive_timeout 65; # 保持连接的时间，也叫超时时间，单位秒 types_hash_max_size 2048; include /etc/nginx/mime.types; # 文件扩展名与类型映射表 default_type application/octet-stream; # 默认文件类型 include /etc/nginx/conf.d/*.conf; # 加载子配置项 server &#123; listen 80; # 配置监听的端口 server_name localhost; # 配置的域名 location / &#123; root /usr/share/nginx/html; # 网站根目录 index index.html index.htm; # 默认首页文件 deny 172.168.22.11; # 禁止访问的ip地址，可以为all allow 172.168.33.44； # 允许访问的ip地址，可以为all &#125; error_page 500 502 503 504 /50x.html; # 默认50x对应的访问页面 error_page 400 404 error.html; # 同上 &#125;&#125; 全局变量 变量名 作用 $host 请求信息中的 Host，如果请求中没有 Host 行，则等于设置的服务器名，不包含端口 $request_method 客户端请求类型，如 GET、POST $remote_addr 客户端的 IP 地址 $args 请求参数 $arg_PARAMETER GET 请求中变量名 PARAMETER 参数的值，例如：$http_user_agent(Uaer-Agent 值)… $content_length 请求头中的 Content-length 字段 $http_user_agent 客户端agent信息 $http_cookie 客户端cookie信息 $remote_addr 客户端的IP地址 $remote_port 客户端端口 $http_user_agent 客户端agent信息 $server_protocol 请求使用的协议，如 HTTP/1.0、HTTP/1.1 $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器端口号 $scheme HTTP 方法（如http，https） … … 反向代理配置 简单配置，例如前端api接口请求转发12345678server&#123; listen 80; server_name localhost; location /api &#123; proxy_pass http://www.xxx.com; &#125;&#125; 请求转发123456789101112131415server&#123; listen 80; server_name localhost; // 把访问 http://127.0.0.1:9001/edu 的请求转发到 http://127.0.0.1:8080 // 把访问 http://127.0.0.1:9001/vod 的请求转发到 http://127.0.0.1:8081 location ~ /edu/ &#123; proxy_pass http://127.0.0.1:8080; &#125; location ~ /vod/ &#123; proxy_pass http://127.0.0.1:8081; &#125;&#125; 跨域配置 反向代理处理跨域问题12345678910server &#123; listen 9001; server_name a.abc.com; // 假设a、b都是服务器的二级域名，指向的ip都一样但是二级域名间请求仍然会跨域 location / &#123; proxy_pass b.abc.com; &#125;&#125; 以上配置会将a.abc.com的请求全部代理到b.abc.com，通常情况下不需要代理全部的请求，所以可以使用请求的后缀来区分静态资源与动态资源的区分。123456789# 请求跨域，约定代理后端服务请求path以/apis/开头location ^~/api/ &#123; # 这里重写了请求，将正则匹配中的第一个分组的path拼接到真正的请求后面，并用break停止后续匹配 rewrite ^/apis/(.*)$ /$1 break; proxy_pass b.abc.com; # 两个域名之间cookie的传递与回写 proxy_cookie_domain a.abc.com b.abc.com;&#125; 设置请求头处理跨域问题123456789101112131415161718192021222324# /etc/nginx/conf.d/b.confserver &#123; listen 80; server_name b.abc.com; add_header &#x27;Access-Control-Allow-Origin&#x27; $http_origin; # 全局变量获得当前请求origin，带cookie的请求不支持* add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;; # 为 true 可带上 cookie add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;; # 允许请求方法 add_header &#x27;Access-Control-Allow-Headers&#x27; $http_access_control_request_headers; # 允许请求的 header，可以为 * add_header &#x27;Access-Control-Expose-Headers&#x27; &#x27;Content-Length,Content-Range&#x27;; if ($request_method = &#x27;OPTIONS&#x27;) &#123; add_header &#x27;Access-Control-Max-Age&#x27; 1728000; # OPTIONS 请求的有效期，在有效期内不用发出另一条预检请求 add_header &#x27;Content-Type&#x27; &#x27;text/plain; charset=utf-8&#x27;; add_header &#x27;Content-Length&#x27; 0; return 204; # 200 也可以 &#125; location / &#123; root /usr/share/nginx/html/b; index index.html; &#125;&#125; 开启gzipnginx配置gzip需要配合前端工程打包成gzip模式才能正常使用。例如vite中使用vite-plugin-compression插件打包资源文件，配置参考 12345678910# /etc/nginx/conf.d/gzip.confgzip on; # 默认off，是否开启gzipgzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; # 采用gzip压缩的MIME文件类型gzip_static on; # 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容gzip_proxied any; # 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩gzip_vary on; # 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩gzip_comp_level 6; # gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6gzip_buffers 16 8k; # 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得gzip_min_length 1k; # 设置最低压缩文件大小gzip_http_version 1.1; # 默认 1.1，启用 gzip 所需的 HTTP 最低版本 负载均衡nginx配置负载均衡有几种分配方式 轮询，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除； weight，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况； ip_hash，每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 session 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的； fair（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装；12345678910111213141516http &#123; upstream myserver &#123; # ip_hash; # ip_hash 方式 # fair; # fair 方式 server 127.0.0.1:8081; # 负载均衡目的服务地址 server 127.0.0.1:8080; server 127.0.0.1:8082 weight=10; # weight 方式，不写默认为 1 &#125; server &#123; location / &#123; proxy_pass http://myserver; proxy_connect_timeout 10; &#125; &#125;&#125; 配置动静分离通过请求后缀名匹配不同资源请求方式实现动静分离，另外可以给静态资源文件设置expires设置缓存时间，从而减少客户端请求的时间。 12345678910111213server &#123; location / &#123; root /dist/; index index.html index.htm; &#125; location /image &#123; root /dist/images; autoindex on; # 开启静态资源列目录 autoindex_exact_size off; # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB autoindex_localtime off; # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间 &#125;&#125; 移动端pc端适配 12345678910111213# /etc/nginx/conf.d/a.abc.com.confserver &#123; listen 80; server_name a.abc.com; location / &#123; root /usr/share/nginx/html/pc; if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) &#123; root /usr/share/nginx/html/mobile; &#125; index index.html; &#125;&#125; 图片防盗链 123456789101112server &#123; listen 80; server_name xxx; # 图片防盗链 location ~* \\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; valid_referers none blocked server_names ~\\.google\\. ~\\.baidu\\. *.qq.com; # 只允许本机 IP 外链引用 if ($invalid_referer)&#123; return 403; &#125; &#125;&#125; 配置图片，字体等静态文件缓存 1234567# 图片缓存时间设置location ~ .*\\.(css|js|jpg|png|gif|swf|woff|woff2|eot|svg|ttf|otf|mp3|m4a|aac|txt)$ &#123; expires 10d;&#125;# 如果不希望缓存expires -1; 以上只涉及到nginx部分常用配置，掌握了这些基本上就能cover住nginx操作，因为平时仅负责前端开发部分的工作，服务器方面实践比较少，仅以此文记录一下方便以后参考。","categories":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/nginx/"}]},{"title":"Vue3富文本编辑器组件封装","slug":"blog26","date":"2023-10-25T00:00:00.000Z","updated":"2024-01-05T05:14:46.712Z","comments":false,"path":"2023/10/25/blog26/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/10/25/blog26/","excerpt":"","text":"近期后台项目有使用富文本编辑器的需求，本文记录一下封装细节 富文本组件库参考 TinyMCE - 富文本编辑器里的 Word ，功能想不到的丰富 tiptap - 多人在线实时协同编辑 CKEditor 5 - 开源免费可商用，行内编辑 Quill - 易扩展、轻量级二开、代码高亮好用 Froala - 插件丰富，UI友好，编辑器里的苹果 summernote - 恰到好处的轻，可直接粘贴图片 Trumbowyg - 超轻量，体积小巧，仅 8KB 以上即是一些常见常用的富文本组件库，各组件库优缺点都有，具体就不详细踩坑分析。作者使用TinyMCE作为实例。 文档地址：TinyMCE中文文档 | TinyMCE官方文档 组件封装 安装相关依赖 1pnpm add tinymce@^5 @tinymce/tinymce-vue 封装组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;template&gt; &lt;div class=&quot;richtext-container&quot;&gt; &lt;Editor id=&quot;myedit&quot; v-model=&quot;content&quot; :init=&quot;initProps&quot; :disabled=&quot;readonly&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref, onMounted, watch, watchEffect&#125; from &#x27;vue&#x27;import tinymce from &#x27;tinymce/tinymce&#x27;import Editor from &#x27;@tinymce/tinymce-vue&#x27;import QiniuUpload from &#x27;@/utils/qnUpload&#x27;// 图片上传方法自行实现// UI资源相关import &quot;tinymce/themes/silver&quot;import &quot;tinymce/icons/default&quot;import &quot;tinymce/icons/default/icons&quot;// 插件import &#x27;tinymce/plugins/image&#x27;import &#x27;tinymce/plugins/paste&#x27; //粘贴图片上传请务必引入此插件const props = defineProps(&#123; modelValue:&#123; type: String, default: &quot;&quot; &#125;, height:&#123; type: Number, default: 278 &#125;, readonly:&#123; type: Boolean, default: true &#125;&#125;)const emits = defineEmits([&#x27;update:modelValue&#x27;])let content = ref()const initProps = reactive(&#123; selector: &#x27;#myedit&#x27;, readonly: props.readonly, height: props.height, resize: false, language_url: &quot;/tinymce/langs/zh-Hans.js&quot;, //语言包路径 language: &quot;zh-Hans&quot;, //语言 skin_url: &quot;/tinymce/skins/ui/custom&quot;, // 定制样式资源路径 content_css: &#x27;/tinymce/skins/ui/custom/content.min.css&#x27;, // 定制样式资源路径 branding: false, menubar: false, toolbar_sticky: true, toolbar_groups: false, elementpath: false, toolbar: `undo redo bold italic underline strikethrough removeformat subscript superscript | alignleft aligncenter alignright alignjustify outdent indent | paste image`, plugins: &#x27;image paste&#x27;, paste_data_images: true, // 图片上传处理 images_upload_handler: async(blobInfo:any, succFun:any, failFun:any)=&gt;&#123; let file = blobInfo.blob() try &#123; const data:any = await QiniuUpload(file,&#x27;image&#x27;,&#x27;xxx&#x27;) succFun(data?.real_url) &#125; catch (error) &#123; failFun(error) &#125; &#125;,&#125;)onMounted(() =&gt; &#123;tinymce.init(&#123;&#125;)&#125;)watchEffect(()=&gt;&#123; content.value = props.modelValue&#125;)watch(content,()=&gt;&#123; updateData()&#125;)const updateData = ()=&gt;&#123; emits(&#x27;update:modelValue&#x27;,content.value)&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.richtext-container&#123; :deep(.tox)&#123; .tox-statusbar&#123; display: none; &#125; &#125;&#125;&lt;/style&gt; 组件使用 12345678910111213&lt;template&gt; &lt;div&gt; &lt;my-richText v-model=&quot;richText&quot; :readonly=&quot;false&quot;&gt;&lt;/my-richText&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, watch &#125; from &#x27;vue&#x27;let richText = ref(&#x27;&lt;p&gt;哈哈哈哈呵呵呵呵&lt;/p&gt;&#x27;)watch(richText,(val)=&gt;&#123; console.log(val)&#125;)&lt;/script&gt; 效果展示 补充说明 TinyMce富文本组件库因其丰富的配置及插件系统更受欢迎，init方法中的参数配置请详细阅读官方文档或中文文档。 样式配置及汉化版教程请自行百度，因比较简单不做过多阐述。 粘贴图片上传与工具栏中的图片上传有一些区别，粘贴图片上传请务必引入paste插件。 readonly属性作者配置不生效，在Editor上使用disabled可以实现同样的只读效果。","categories":[{"name":"组件","slug":"组件","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"vue-3","slug":"vue-3","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/vue-3/"}]},{"title":"AI及设计相关","slug":"blog24","date":"2023-09-04T16:00:00.000Z","updated":"2024-01-05T05:14:46.712Z","comments":false,"path":"2023/09/05/blog24/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/09/05/blog24/","excerpt":"","text":"AI资源导航平台 [AI资源]https://73496.com/#term-12 [设计资源]https://jiafangbb.com/#term-15220 提示词推荐平台 [prompthero]https://prompthero.com/ [promptPerfect]https://promptperfect.jinaai.cn/ [Finding.art]https://finding.art/#/ [openart.ai]https://openart.ai/ [playgroundai]https://playgroundai.com/ [arthub.ai]https://arthub.ai/","categories":[{"name":"资源","slug":"资源","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"AIGC","slug":"AIGC","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/AIGC/"}]},{"title":"MutationObserver概述及应用","slug":"blog23","date":"2023-08-22T16:00:00.000Z","updated":"2024-01-05T05:14:46.712Z","comments":false,"path":"2023/08/23/blog23/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/08/23/blog23/","excerpt":"","text":"前言：紧接上文前端性能监控一文中在FMP,FCP算法设计中需要使用到MutationObserver对象进行一些DOM监控的操作，本文详细介绍一下MutationObserver Api 简介MutationObserver用于监控DOM树变化，提供了异步方法来监听DOM元素的增加、删除、属性变化操作。开发者可以借助此方法对DOM树变化做出相应的响应。 构造函数MutationObserver()DOM 规范中的 MutationObserver() 构造函数—是 MutationObserver 接口内容的一部分—创建并返回一个新的观察器，它会在触发指定 DOM 事件时，调用指定的回调函数。MutationObserver 对 DOM 的观察不会立即启动；而必须先调用 observe() 方法来确定，要监听哪一部分的 DOM 以及要响应哪些更改。 observe参数: target: 需要观测的目标节点 options: attributes：是否监测元素的属性变化。 attributeOldValue：是否在属性变化时记录旧值。 attributeFilter：指定要监测的属性列表。 childList：是否监测子元素的添加或移除。 subtree：是否监测后代元素的变化。 characterData：是否监测文本节点的内容变化。 characterDataOldValue：是否在文本节点内容变化时记录旧值。 12345678910// 代码实例var targetNode = document.querySelector(&quot;#someElement&quot;);var observerOptions = &#123; childList: true, // 观察目标子节点的变化，是否有添加或者删除 attributes: true, // 观察属性变动 subtree: true, // 观察后代节点，默认为 false&#125;;var observer = new MutationObserver(callback);observer.observe(targetNode, observerOptions); 常见的使用场景 动态内容加载当页面内容是异步加载或者说是动态生成时，可以使用MutationObserver来监控内容变化，并在变化后进行相应的处理，如页面更新，监听事件的绑定。例如：无限滚动场景下可以监听新内容加载到页面，在DOM变化后添加相应的元素或事件。 表单输入动态验证当需要实时校验用户输入内容时，使用MutationObserver来监控表单内容，值的变化以及禁用状态等，即可实现表单的动态校验。 响应式布局当页面布局需要根据DOM变化自适应调整时，使用MutationObserver来监测相关元素的变化，并根据变化动态地调整页面布局。例如，在响应式网页设计中，当窗口大小发生变化或元素被添加或移除时，可以使用MutationObserver来监听相关元素的变化，并根据变化重新计算和调整页面布局，以适应不同的设备和屏幕尺寸。 组件内部监听在自定义组件的开发中，MutationObserver可以用于监听组件内部的DOM变化，以及对应的属性变化。这样可以在组件内部做出相应的处理，如更新组件的状态、重新渲染组件等。例如，当一个自定义组件中的某个子元素被添加或移除时，可以使用MutationObserver来监听这些变化，并在变化发生后更新组件的状态或重新渲染组件。 场景实例 动态校验表单元素 123456789101112131415161718192021222324252627282930313233343536373839404142// 目标元素（表单）const form = document.querySelector(&#x27;#myForm&#x27;);// 创建一个 MutationObserver 实例const observer = new MutationObserver((mutationsList) =&gt; &#123; // 在每次变化时进行处理 for (let mutation of mutationsList) &#123; // 检查是否是值发生变化的子节点 if (mutation.type === &#x27;childList&#x27; &amp;&amp; mutation.target.nodeName === &#x27;INPUT&#x27;) &#123; // 执行动态校验逻辑 validateForm(); &#125; // 检查是否是属性变化 if (mutation.type === &#x27;attributes&#x27; &amp;&amp; mutation.attributeName === &#x27;disabled&#x27;) &#123; // 执行动态校验逻辑 validateForm(); &#125; &#125;&#125;);// 配置 MutationObserver 监听的类型和目标节点const config = &#123; childList: true, attributes: true, subtree: true &#125;;// 开始观察表单的变化observer.observe(form, config);// 动态校验表单内容的函数function validateForm() &#123; // 获取表单元素 const input1 = document.querySelector(&#x27;#input1&#x27;); const input2 = document.querySelector(&#x27;#input2&#x27;); // 获取表单元素的值和禁用状态 const value1 = input1.value; const value2 = input2.value; const disabled1 = input1.disabled; const disabled2 = input2.disabled; // 执行校验逻辑 // ...&#125; 响应式布局 1234567891011121314151617181920212223242526272829303132333435363738// 创建 MutationObserver 实例const observer = new MutationObserver(function(mutationsList) &#123; for (let mutation of mutationsList) &#123; if (mutation.type === &#x27;childList&#x27;) &#123; // 子节点被添加或移除的处理逻辑 adjustLayout(); &#125; &#125;&#125;);// 配置 MutationObserver 监听的类型和目标节点const config = &#123; childList: true, subtree: true &#125;;// 开始观察窗口大小变化和元素添加或移除window.addEventListener(&#x27;resize&#x27;, adjustLayout);observer.observe(document.body, config);// 初始化页面布局adjustLayout();// 页面布局调整函数function adjustLayout() &#123; // 获取窗口宽度 const windowWidth = window.innerWidth; // 根据窗口宽度调整布局 if (windowWidth &gt; 1024) &#123; // 大屏幕布局 // ... &#125; else if (windowWidth &gt; 768) &#123; // 中屏幕布局 // ... &#125; else &#123; // 小屏幕布局 // ... &#125;&#125; 参考内容MDN Web Docs - MutationObserver 注：实例代码均由ChatGpt生成","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"}]},{"title":"前端性能优化","slug":"blog22","date":"2023-08-15T16:00:00.000Z","updated":"2024-01-05T05:14:46.711Z","comments":false,"path":"2023/08/16/blog22/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/08/16/blog22/","excerpt":"","text":"前端性能优化的宗旨即追求更快，但是也应避免过渡优化。以现有互联网产品为例各厂商性能标准也不一致，在各标准找到适合自己公司用户体量及业务要求的标准需要不断的实践。 前端性能指标 TTFB : ResponseStart - RequestStart (首包时间，关注网络链路耗时) FPT : ResponseEnd - FetchStart （首次渲染时间 / 白屏时间） TTI : DomInteractive - FetchStart （首次可交付时间） Ready : DomContentLoadEventEnd - FetchStart （加载完成时间） Load : LoadEventStart - FetchStart （页面完全加载时间） performance timing api 计算常见指标可以使用谷歌封装好的js库web-vitals FMP(first meaningful paint) 含义：首次有意义绘制，通常指页面主要内容出现在屏幕上的时间，是用户感知加载体验的主要指标。 统计逻辑：目前没有统一的统计方法。 参考文章：前端监控 - 首屏统计的前世今生前端监控实践 - FMP的智能获取算法 算法流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282const utils = &#123; //获取当前样式 getStyle(element, att) &#123; //特性侦测 if (window.getComputedStyle) &#123; //优先使用W3C规范 return window.getComputedStyle(element)[att]; &#125; else &#123; //针对IE9以下兼容 return element.currentStyle[att]; &#125; &#125;&#125;const START_TIME = performance &amp;&amp; performance.timing.responseEnd;const IGNORE_TAG_SET = [&quot;SCRIPT&quot;, &quot;STYLE&quot;, &quot;META&quot;, &quot;HEAD&quot;, &quot;LINK&quot;];const TAG_WEIGHT_MAP = &#123; SVG: 2, IMG: 2, CANVAS: 4, OBJECT: 4, EMBED: 4, VIDEO: 4&#125;;const LIMIT = 1000;const WW = window.innerWidth;const WH = window.innerHeight;const VIEWPORT_AREA = WW * WH;const DELAY = 500;class FMPTiming &#123; constructor() &#123; this.statusCollector = []; this.flag = true; this.muo = MutationObserver; this.observer = null; this.callbackCount = 1; this.mp = &#123;&#125;; this.initObserver(); &#125; firstSnapshot() &#123; let t = window.__DOMSTART - START_TIME; let bodyTarget = document.body; if (bodyTarget) &#123; this.doTag(bodyTarget, this.callbackCount++); &#125; this.statusCollector.push(&#123; t &#125;); &#125; initObserver() &#123; this.firstSnapshot(); this.observer = new MutationObserver(() =&gt; &#123; let t = Date.now() - START_TIME; let bodyTarget = document.body; if (bodyTarget) &#123; this.doTag(bodyTarget, this.callbackCount++); &#125; this.statusCollector.push(&#123; t &#125;); &#125;); this.observer.observe(document, &#123; childList: true, subtree: true &#125;); if (document.readyState === &quot;complete&quot;) &#123; this.calFinallScore(); &#125; else &#123; window.addEventListener( &quot;load&quot;, () =&gt; &#123; this.calFinallScore(); &#125;, true ); &#125; &#125; initResourceMap() &#123; performance.getEntries().forEach(item =&gt; &#123; this.mp[item.name] = item.responseEnd; &#125;); &#125; doTag(target, callbackCount) &#123; let tagName = target.tagName; if (IGNORE_TAG_SET.indexOf(tagName) === -1) &#123; let childrenLen = target.children ? target.children.length : 0; if (childrenLen &gt; 0) &#123; for (let childs = target.children, i = childrenLen - 1; i &gt;= 0; i--) &#123; if (childs[i].getAttribute(&quot;f_c&quot;) === null) &#123; childs[i].setAttribute(&quot;f_c&quot;, callbackCount); &#125; this.doTag(childs[i], callbackCount); &#125; &#125; &#125; &#125; calFinallScore() &#123; if (MutationObserver &amp;&amp; this.flag) &#123; if (!this.checkCanCal(START_TIME)) &#123; console.time(&quot;calTime&quot;); this.observer.disconnect(); this.flag = false; let res = this.deepTraversal(document.body); let tp; res.dpss.forEach(item =&gt; &#123; if (tp &amp;&amp; tp.st) &#123; if (tp.st &lt; item.st) &#123; tp = item; &#125; &#125; else &#123; tp = item; &#125; &#125;); console.log(tp, this.statusCollector); this.initResourceMap(); let resultSet = this.filterTheResultSet(tp.els); let fmpTiming = this.calResult(resultSet); console.log(&quot;fmp : &quot;, fmpTiming); console.timeEnd(&quot;calTime&quot;); &#125; else &#123; setTimeout(() =&gt; &#123; this.calFinallScore(); &#125;, DELAY); &#125; &#125; &#125; calResult(resultSet) &#123; let rt = 0; resultSet.forEach(item =&gt; &#123; let t = 0; if (item.weight === 1) &#123; let index = +item.node.getAttribute(&quot;f_c&quot;) - 1; t = this.statusCollector[index].t; &#125; else if (item.weight === 2) &#123; if (item.node.tagName === &quot;IMG&quot;) &#123; t = this.mp[item.node.src]; &#125; else if (item.node.tagName === &quot;SVG&quot;) &#123; let index = +item.node.getAttribute(&quot;f_c&quot;) - 1; t = this.statusCollector[index].t; &#125; else &#123; //background image let match = utils.getStyle(item.node, &#x27;background-image&#x27;).match(/url\\(\\&quot;(.*?)\\&quot;\\)/); let s; if (match &amp;&amp; match[1]) &#123; s = match[1]; &#125; if (s.indexOf(&quot;http&quot;) == -1) &#123; s = location.protocol + match[1]; &#125; t = this.mp[s]; &#125; &#125; else if (item.weight === 4) &#123; if (item.node.tagName === &quot;CANVAS&quot;) &#123; let index = +item.node.getAttribute(&quot;f_c&quot;) - 1; t = this.statusCollector[index].t; &#125; else if (item.node.tagName === &quot;VIDEO&quot;) &#123; t = this.mp[item.node.src]; !t &amp;&amp; (t = this.mp[item.node.poster]); &#125; &#125; console.log(t, item.node); rt &lt; t &amp;&amp; (rt = t); &#125;); return rt; &#125; filterTheResultSet(els) &#123; let sum = 0; els.forEach(item =&gt; &#123; sum += item.st; &#125;); let avg = sum / els.length; return els.filter(item =&gt; &#123; return item.st &gt; avg; &#125;); &#125; deepTraversal(node) &#123; if (node) &#123; let dpss = []; for (let i = 0, child; (child = node.children[i]); i++) &#123; let s = this.deepTraversal(child); if (s.st) &#123; dpss.push(s); &#125; &#125; return this.calScore(node, dpss); &#125; return &#123;&#125;; &#125; calScore(node, dpss) &#123; let &#123; width, height, left, top, bottom, right &#125; = node.getBoundingClientRect(); let f = 1; if (WH &lt; top || WW &lt; left) &#123; //不在可视viewport中 f = 0; &#125; let sdp = 0; dpss.forEach(item =&gt; &#123; sdp += item.st; &#125;); let weight = TAG_WEIGHT_MAP[node.tagName] || 1; if ( weight === 1 &amp;&amp; utils.getStyle(node, &#x27;background-image&#x27;) &amp;&amp; utils.getStyle(node, &#x27;background-image&#x27;) !== &quot;initial&quot; ) &#123; weight = TAG_WEIGHT_MAP[&quot;IMG&quot;]; //将有图片背景的普通元素 权重设置为img &#125; let st = width * height * weight * f; let els = [&#123; node, st, weight &#125;]; let areaPercent = this.calAreaPercent(node); if (sdp &gt; st * areaPercent || areaPercent === 0) &#123; st = sdp; els = []; dpss.forEach(item =&gt; &#123; els = els.concat(item.els); &#125;); &#125; return &#123; dpss, st, els &#125;; &#125; checkCanCal(start) &#123; let ti = Date.now() - start; return !( ti &gt; LIMIT || ti - ((this.statusCollector &amp;&amp; this.statusCollector.length &amp;&amp; this.statusCollector[this.statusCollector.length - 1].t) || 0) &gt; 1000 ); &#125; calAreaPercent(node) &#123; let &#123; left, right, top, bottom, width, height &#125; = node.getBoundingClientRect(); let wl = 0; let wt = 0; let wr = WW; let wb = WH; let overlapX = right - left + (wr - wl) - (Math.max(right, wr) - Math.min(left, wl)); if (overlapX &lt;= 0) &#123; //x 轴无交点 return 0; &#125; let overlapY = bottom - top + (wb - wt) - (Math.max(bottom, wb) - Math.min(top, wt)); if (overlapY &lt;= 0) &#123; return 0; &#125; return (overlapX * overlapY) / (width * height); &#125;&#125;new FMPTiming(); FCP(first contentful paint) 含义：浏览器第一次绘制非背景内容时间（文本、图片、非白色canvas或svg） 统计逻辑：通过performance.getEntriesByType(‘paint’)，取第二个pain的时间，或者通过Mutation Observer观察到首次节点变动的时间。 1234567891011121314151617181920const domEntries = []const observer = new MutationObserver((mutationsList)=&gt;&#123; for(var mutation of mutationsList) &#123; if (mutation.type == &#x27;childList&#x27;) &#123; console.log(&#x27;A child node has been added or removed.&#x27;) &#125; if (mutation.type == &#x27;addedNodes&#x27;) &#123; //TODO新增了节点，做处理，计算此时的可见性/位置/出现时间等信息，然后 push 进数组 domEntries.push(mutation) &#125; &#125;&#125;)function getFPTime()&#123; const timings = performance.getEntriesByType(&#x27;paint&#x27;); if(timings.length &gt; 1)return timings[1] return timings ? Math.round(timings.startTime) : null //伪代码,算 DOM 变化时的最小那个时间，即节点首次变动的时间 return Math.round(domEntries.length ? Math.min(...domEntries.map(entry =&gt; entry.time)) : 0)&#125; 前端性能分析工具lightHouseWebPageTest","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"}]},{"title":"Mac HomeBrew安装及镜像配置","slug":"blog21","date":"2023-07-07T16:00:00.000Z","updated":"2023-07-08T07:42:28.310Z","comments":false,"path":"2023/07/08/blog21/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/07/08/blog21/","excerpt":"","text":"安装1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 安装缓慢问题 替换homebrew.git12cd $(brew --repo)git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 替换homebrew-core.git12cd $(brew --repo)/Library/Taps/homebrew/homebrew-coregit remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git 查看shell配置文件，根据配置文件修改步骤4|51echo $SHELL /bin/zsh替换homebrew-bottles12echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc /bin/bash替换homebrew-bottles12echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 恢复默认配置12345678// step1:cd $(brew --repo)git remote set-url origin https://github.com/Homebrew/brew.git// step2:cd $(brew --repo)/Library/Taps/homebrew/homebrew-coregit remote set-url origin https://github.com/Homebrew/homebrew-core.git// step3:// 将添加到~/.zshrc|~/.bash_profile文件的语句注释掉即可","categories":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Node版本管理工具nvm简介","slug":"blog19","date":"2023-07-04T16:00:00.000Z","updated":"2024-01-05T05:14:46.711Z","comments":false,"path":"2023/07/05/blog19/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/07/05/blog19/","excerpt":"","text":"nvm安装MacOS详见Windows详见 nvm常见命令 12345678910111213141516171819nvm list 查看已经安装的版本nvm list installed 查看已经安装的版本nvm list available 查看网络可以安装的版本nvm install 安装最新版本nvmnvm use &lt;version&gt; ## 切换使用指定的版本nodenvm ls 列出所有版本nvm current显示当前版本nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包nvm on 打开nodejs控制nvm off 关闭nodejs控制nvm proxy 查看设置与代理nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是 https://github.com/npm/npm/archive/.nvm uninstall &lt;version&gt; 卸载制定的版本nvm use [version] [arch] 切换制定的node版本和位数nvm root [path] 设置和查看root路径nvm version 查看当前的版本 注意事项 非首次安装需要将本地环境的nodejs删除干净，首次安装后需要升级nvm也需要将本地所有安装的nodejs分别uninstall windows卸载nvm: 找到nvm安装目录，如果目录中有unins000.exe文件直接执行即可 如若没有unins000.exe，按照如下步骤执行 删除nvm文件夹 文件夹内右键 此电脑–点击属性–找到高级系统设置–环境变量。 删除用户变量和系统变量中名为 NVM_HOME 和 NVM_SYMLINK 两个变量。其他的不要改。 用户变量和系统变量中path中的 %NVM_HOME%;%NVM_SYMLINK% 两个属性，其他的不要改。","categories":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"}]},{"title":"Element-plus图标封装","slug":"blog20","date":"2023-07-04T16:00:00.000Z","updated":"2024-01-05T05:14:46.711Z","comments":false,"path":"2023/07/05/blog20/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/07/05/blog20/","excerpt":"","text":"按需加载并方便使用,不需要在每个页面单独引入Icon按需加载配置详见 安装依赖1npm install @element-plus/icons-vue utils/icon.ts123456789101112131415161718192021222324import &#123; createVNode &#125; from &#x27;vue&#x27;import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;interface EIconInf&#123; type: string, size?: number, color?: string, cursor?: boolean&#125;export const EIcon = (props: EIconInf) =&gt; &#123; const &#123; type, size=20, color=&#x27;&#x27;, cursor=true &#125; = props const EIcon: &#123; [key: string]: any &#125; = ElementPlusIconsVue return createVNode( EIcon[type], &#123; style:&#123; width: `$&#123;size&#125;px`, color: color ? color : &#x27;inherit&#x27;, cursor: cursor ? &#x27;pointer&#x27; : &#x27;none&#x27;, &#125; &#125; )&#125; 在main.js中引入并注册1234import &#123; EIcon &#125; from &#x27;./utils/icon&#x27;...//注册EIcon组件app.component(&#x27;EIcon&#x27;, EIcon) 页面使用12345&lt;template&gt; &lt;div&gt; &lt;e-icon type=&quot;House&quot;&gt;&lt;/e-icon&gt; &lt;/div&gt;&lt;/template&gt;","categories":[{"name":"组件","slug":"组件","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/Element/"}]},{"title":"rsa加解签及加解密常用工具","slug":"blog18","date":"2023-06-05T16:00:00.000Z","updated":"2023-07-08T07:32:07.355Z","comments":false,"path":"2023/06/06/blog18/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/06/06/blog18/","excerpt":"","text":"依赖 jsencrypt encryptlong jsrsasign npm库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import JSEncrypt from &#x27;jsencrypt&#x27;import Encrypt from &#x27;encryptlong&#x27;import jsrsasign from &#x27;jsrsasign&#x27;/** * 生成随机长度字符串 * @param &#123;Number&#125; length 字符串长度 */export const generateRandomString = (length) =&gt; &#123; let result = &#x27;&#x27;; let characters = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;; let charactersLength = characters.length; for (let i = 0; i &lt; length; i++) &#123; result += characters.charAt(Math.floor(Math.random() * charactersLength)); &#125; return result;&#125;/** * 私钥加签 * @param &#123;object&#125; params 加密对象 * @param &#123;string&#125; privateKey 私钥 */export const generateRSASign = (params, privateKey)=&gt;&#123; // 1. 将参数按照字典序排序 const sortedParams = Object.keys(params).sort(); // 2. 将参数按照 key=value 的形式拼接成字符串 const paramString = sortedParams.map(key =&gt; `$&#123;params[key]&#125;`).join(&#x27;/n&#x27;); // 3. 对参数字符串进行 RSA 签名 const rsa = new jsrsasign.RSAKey() rsa = jsrsasign.KEYUTIL.getKey(privateKey) const signature = new jsrsasign.KJUR.crypto.Signature(&#123;alg: &#x27;SHA256withRSA&#x27;&#125;) signature.init(rsa) signature.updateString(paramString) const signResult = signature.sign() // 4. 将签名转换为 Base64 编码 const signBase64 = jsrsasign.hextob64(signResult) return signBase64&#125;/** * 公钥验签 * @param &#123;string&#125; signData 加签数据 * @param &#123;string&#125; data 加签之后得到的签文 * @param &#123;string&#125; publicKey 公钥 */export const verifyRSASign = (signData, data, publicKey) =&gt;&#123; try &#123; const rsa = new jsrsasign.RSAKey() rsa = jsrsasign.KEYUTIL.getKey(publicKey) let signatureVf = new jsrsasign.KJUR.crypto.Signature(&#123; alg: &quot;SHA256withRSA&quot;, prvkeypem: rsa &#125;) signatureVf.updateString(data) let result = signatureVf.verify(jsrsasign.b64tohex(signData)) console.log(&quot;jsrsasign verify: &quot; + result) return result &#125; catch (e) &#123; console.error(e) &#125;&#125;/** * JSEncrypt加密 * @param &#123;string&#125; data 加密对象 * @param &#123;string&#125; publicKey 公钥 */export const getJSEncrypt = (data,publicKey)=&gt;&#123; let jsencrypt = new JSEncrypt() jsencrypt.setPublicKey(publicKey) let result = jsencrypt.encrypt(data) return result&#125;/** * JSEncrypt解密 * @param &#123;string&#125; data 解密对象 * @param &#123;string&#125; privateKey 私钥 */export const getJSDecrypt = (data,privateKey)=&gt;&#123; let jsencrypt = new JSEncrypt() jsencrypt.setPrivateKey(privateKey) let result = jsencrypt.encrypt(data) return result&#125;/** * Encrypt加密 * @param &#123;string&#125; data 加密对象 * @param &#123;string&#125; publicKey 公钥 */export const getEncrypt = (data,publicKey)=&gt;&#123; let encrypt = new Encrypt(); encrypt.setPublicKey(publicKey); let result = encrypt.encryptLong(JSON.stringify(data)) return result&#125;/** * Encrypt解密 * @param &#123;string&#125; data 解密对象 * @param &#123;string&#125; privateKey 私钥 */export const getDecrypt = (data,privateKey)=&gt;&#123; let decrypt = new Encrypt(); decrypt.setPrivateKey(privateKey); let result = decrypt.decryptLong(data) return result&#125;","categories":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"}]},{"title":"Vue2电池小图标","slug":"blog17","date":"2023-05-25T16:00:00.000Z","updated":"2024-01-05T05:14:46.711Z","comments":false,"path":"2023/05/26/blog17/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/05/26/blog17/","excerpt":"","text":"简单的电池小图标，根据电量展示不同的颜色。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;template&gt; &lt;div class=&quot;battery-container&quot;&gt; &lt;div class=&quot;shell&quot;&gt; &lt;div v-for=&quot;(item,index) in batteryChunk&quot; class=&quot;block&quot; :key=&quot;index&quot; :style=&quot;&#123; background: `$&#123;batteryColor&#125;` &#125;&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:&#123; capacity:&#123; type: [Number,String], &#125; &#125;, computed:&#123; batteryChunk()&#123; return this.findInterval(this.capacity) &#125;, batteryColor()&#123; if(this.batteryChunk &gt;=0 &amp;&amp; this.batteryChunk &lt;= 1)&#123; return &#x27;#FE5F69&#x27; &#125;else if(this.batteryChunk &gt; 1 &amp;&amp; this.batteryChunk &lt;=4)&#123; return &#x27;#FFC95C&#x27; &#125;else&#123; return &#x27;#64BA8C&#x27; &#125; &#125; &#125;, methods:&#123; findInterval(num) &#123; var intervalSize = 100 / 6 var interval = Math.floor(num / intervalSize) if (interval === 6) &#123; return interval &#125; else &#123; return interval + 1 &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&#x27;less&#x27; scoped&gt;.battery-container&#123; width: 48px; height: 24px; border: 4px solid #DFE6EE ; border-radius: 4px; position: relative; transform: scale(0.5); transform-origin: left top; &amp;:after&#123; content: &quot;&quot;; display: block; height: 12px; width: 4px; position: absolute; background:#DFE6EE ; right: -8px; top: 0; bottom: 0; margin: auto 0; &#125; .shell&#123; width: 100%; height: 100%; box-sizing: border-box; padding: 2px; background: #F8FAFC ; display: grid; grid-template-columns: repeat(6,1fr); grid-column-gap: 2px; .block&#123; width: 100%; height: 100%; &#125; &#125;&#125;&lt;/style&gt;","categories":[{"name":"组件","slug":"组件","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"vue-2","slug":"vue-2","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/vue-2/"}]},{"title":"Vue3 H5调用相机扫描二维码","slug":"blog16","date":"2023-05-22T16:00:00.000Z","updated":"2023-07-08T07:32:07.355Z","comments":false,"path":"2023/05/23/blog16/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/05/23/blog16/","excerpt":"","text":"使用第三方库目前比较流行的扫描二维码库有zxing-js、quaggaJS、Html5Qrcode等，可以在Vue3项目中安装并使用这些库来实现扫描二维码功能。 1npm install zxing-js 12345678import &#123; BrowserQRCodeReader &#125; from &#x27;@zxing/library&#x27;;const codeReader = new BrowserQRCodeReader();codeReader.decodeFromInputVideoDevice(undefined, &#x27;video&#x27;).then((result) =&gt; &#123; console.log(result.text);&#125;).catch((err) =&gt; &#123; console.error(err);&#125;); 使用浏览器原生API现代浏览器提供了WebRTC API，可以使用getUserMedia方法获取摄像头视频流，再使用Canvas API将视频流渲染到画布上，最后使用jsQR库解析二维码。 1npm install jsqr 1234567891011121314151617181920212223import jsQR from &#x27;jsqr&#x27;;const video = document.createElement(&#x27;video&#x27;);navigator.mediaDevices.getUserMedia(&#123; video: true &#125;).then((stream) =&gt; &#123; video.srcObject = stream; video.play();&#125;).catch((err) =&gt; &#123; console.error(err);&#125;);const canvas = document.createElement(&#x27;canvas&#x27;);const ctx = canvas.getContext(&#x27;2d&#x27;);function scanQRCode() &#123; ctx.drawImage(video, 0, 0, canvas.width, canvas.height); const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const code = jsQR(imageData.data, imageData.width, imageData.height); if (code) &#123; console.log(code.data); &#125; else &#123; setTimeout(scanQRCode, 100); &#125;&#125;scanQRCode(); 需要注意的是，getUserMedia方法需要在https或localhost环境下才能正常使用，否则会报错。","categories":[{"name":"vue","slug":"vue","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/vue/"}],"tags":[{"name":"vue-3","slug":"vue-3","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/vue-3/"}]},{"title":"Vue3核心模块及虚拟DOM","slug":"blog15","date":"2023-02-28T16:00:00.000Z","updated":"2023-07-08T07:32:07.354Z","comments":false,"path":"2023/03/01/blog15/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/03/01/blog15/","excerpt":"","text":"img[alt=\"img\"]{ width:500px; } vue3三个核心模块Reactive Module 跟踪、观察变化并做出响应的改变 Compiler Module 获取HTML模板并将其编译成渲染函数 Render Module Render Phase：返回虚拟节点 Mount Phase：使用虚拟节点创建页面 Patch Phase：以补丁的形式更新页面 组件执行过程中Vue的操作编译模块将HTML转换成一个渲染函数 初始化响应式对象使用响应式模块 进入Render渲染阶段调用render函数，引用响应式对象，观察对象变化，render返回一个虚拟DOM节点 使用虚拟节点创建web界面 如果响应对象发生变化，再次调用render创建虚拟DOM节点，新旧节点对比发送补丁更新页面 虚拟DOM虚拟DOM优点 保证性能下限：虚拟DOM需要适配任何上层API可能产生的操作，DOM操作的实现必须是普适的，因此虚拟DOM的性能并不是最优的，但是相较于直接操作DOM性能还是要好很多，因此框架的虚拟DOM可以保证不需要手动优化情况下提供还不错的功能，即保证性能下限。 无需手动操作DOM：无需手动操作DOM，只需要写好View-Model代码逻辑，框架会处理好数据与DOM的双向绑定，帮助我们以可预期的方式更新视图，极大程度的提高开发效率。 跨平台：虚拟DOM本质上就是js的对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便的跨平台操作。 虚拟DOM的缺点 无法禁止极致优化：虽然虚拟DOM+合理的优化可以应对大部分应用的性能需求，但是在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。 需要额外的创建函数，如createElement或者h函数。","categories":[{"name":"vue","slug":"vue","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/vue/"}],"tags":[{"name":"vue-3","slug":"vue-3","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/vue-3/"}]},{"title":"Promise概述及应用","slug":"blog14","date":"2023-02-19T16:00:00.000Z","updated":"2023-07-08T07:32:07.354Z","comments":false,"path":"2023/02/20/blog14/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/02/20/blog14/","excerpt":"","text":"1.Promise概述Promise是异步编程的解决方案。简单来说是一个容器，里面保存了异步操作的结果。Promise有如下特点： 对象内部状态不受外界环境影响。promise仅有三种状态pending(进行中)、fulfilled(已成功)、rejected(已失败)。只有异步操作的结果可以决定当前属于哪一种状态。 状态一旦确定就无法改变，任何时候都可以得到这个结果。promise的结果改变只有两种状态：从pending-&gt;fulfilled、从pending-&gt;rejected。只要这两个状态发生就无法改变。Promise的缺点： 无法取消Promise,一旦新建就会立即执行，无法中途取消。 如果不设置回调函数，promise内部抛出的错误无法被外界捕获。 当处于pending状态时，无法得知目前进展到哪一阶段。 注意：在构造Promise的时候，构造函数内部的代码是立即执行的。 2.基本用法 通常使用new Promise构造一个新的promise函数。 12345678const promise = new Promise((resolve, reject) =&gt; &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); then()方法：接收两个回调函数，一个作为resolve状态回调，一个作为reject回调 12345promise.then(res=&gt;&#123; console.log(res) // value&#125;,err=&gt;&#123; console.log(err) // error&#125;) catch()方法：接收一个回调函数，用来指定发生错误时的函数。相当于then方法的第二个函数。 123456promise.then(res=&gt;&#123; console.log(res) // value&#125;)promise.catch(err=&gt;&#123; console.log(err) // error&#125;) finally()方法：用于指定不管Promise对象最后状态如何，都会执行的方法。 1234promise.then(res =&gt; &#123;···&#125;).catch(err =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;) all()方法：用于将多个Promise实例包装成一个新的Promise实例。只有多个Promise的返回状态都为resolve时新的Promise状态才为resolve,任意一个Promise状态为reject时新Promise状态为reject。如果参数Promise定义了自己的catch方法，那么一旦被rejected不会触发Promise.all()的catch方法。如果参数Promise没有自己的catch方法，则调用Promise.all()的catch方法。 123456789101112131415161718const p = Promise.all([p1, p2, p3]);const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;);&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;);&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了] race()方法：同样是将多个Promise实例包装成一个新Promise实例，与all不同的是：某一个参数Promise先改变状态，则返回率先改变的那个Promise的返回值，直接结束包装实例。 1const p = Promise.race([p1, p2, p3]); any()方法：只要有一个参数实例变成fulfilled状态，包装实例变成fulfilled状态，如果所有的实例都变成rejected状态，包装实例会变成rejected状态。与race方法类似，区别是：Promise.any()不会因为某个Promise变成rejected状态而结束，必须等到所有参数的Promise变成rejected状态才结束。 1const p = Promise.any([p1, p2, p3]); resolve()方法：将现有对象转化为Promise对象。 123Promise.resolve(&#x27;foo&#x27;)// 等价于new Promise(resolve =&gt; resolve(&#x27;foo&#x27;)) resolve参数分四种情况： 参数是一个Promise实例：Promise.resolve不做任何修改、原封不动返回这个实例。 参数是一个thenable对象(具有then方法的对象)：Promise.resolve()方法会将这个对象转为Promise对象，然后立即执行thenable对象的then()方法。 123456789let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function (value) &#123; console.log(value); // 42&#125;); 参数不是具有then()方法的对象，或根本就不是对象：如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 12345const p = Promise.resolve(&#x27;Hello&#x27;);p.then(function (s) &#123; console.log(s)&#125;);// Hello 不带有任何参数:Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。 12345678910setTimeout(function () &#123; console.log(&#x27;three&#x27;);&#125;, 0);Promise.resolve().then(function () &#123; console.log(&#x27;two&#x27;);&#125;);console.log(&#x27;one&#x27;);// one// two// three reject()方法：返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject(&#x27;出错了&#x27;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了","categories":[{"name":"ES6","slug":"ES6","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/ES6/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"}]},{"title":"Reflect概述及应用","slug":"blog12","date":"2023-02-13T16:00:00.000Z","updated":"2023-07-08T07:32:07.354Z","comments":false,"path":"2023/02/14/blog12/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/02/14/blog12/","excerpt":"","text":"Reflect概述Reflect是ES6提供的操作对象的Api,其主要目的有 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。 Reflect静态方法 Reflect.get(target,name,receiver):查找并返回target对象的name属性，如果没有该属性返回undefined 123456789101112131415161718var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;var myReceiverObject = &#123; foo: 4, bar: 4,&#125;;// Reflect.get的第一个参数不是对象会报错Reflect.get(myObject, &#x27;foo&#x27;) // 1Reflect.get(myObject, &#x27;bar&#x27;) // 2Reflect.get(myObject, &#x27;baz&#x27;) // 3// 如果有reciver参数则getter的this绑定receiverReflect.get(myObject, &#x27;baz&#x27;, myReceiverObject) // 8 Reflect.set(target,name,value,receiver):设置对象的name属性值为value 1234567891011121314var myObject = &#123; foo: 4, set bar(value) &#123; return this.foo = value; &#125;,&#125;;var myReceiverObject = &#123; foo: 0,&#125;;Reflect.set(myObject, &#x27;bar&#x27;, 1, myReceiverObject);myObject.foo // 4myReceiverObject.foo // 1 Reflect.has(obj,name):判断obj对象是否包含name属性 12345678var myObject = &#123; foo: 1,&#125;;// 旧写法&#x27;foo&#x27; in myObject // true// 新写法Reflect.has(myObject, &#x27;foo&#x27;) // true Reflect.deleteProperty(obj, name):等同于delete obj[name]方法，删除对象的name属性值 123456const myObj = &#123; foo: &#x27;bar&#x27; &#125;;// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, &#x27;foo&#x27;); Reflect.construct(target,args):等同于new target(…args)提供了一种不使用new调用构造函数的方法。 12345678function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting(&#x27;张三&#x27;);// Reflect.construct 的写法const instance = Reflect.construct(Greeting, [&#x27;张三&#x27;]); Reflect.apply(func,thisArg,args):等同于Function.prototype.apply.call(func,thisArg,args)用于绑定this对象后执行给定函数。 1234567891011const ages = [11, 33, 12, 54, 18, 96];// 旧写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// 新写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.ownKeys(target):返回对象的所有属性，等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和 1234567891011121314151617var myObject = &#123; foo: 1, bar: 2, [Symbol.for(&#x27;baz&#x27;)]: 3, [Symbol.for(&#x27;bing&#x27;)]: 4,&#125;;// 旧写法Object.getOwnPropertyNames(myObject)// [&#x27;foo&#x27;, &#x27;bar&#x27;]Object.getOwnPropertySymbols(myObject)//[Symbol(baz), Symbol(bing)]// 新写法Reflect.ownKeys(myObject)// [&#x27;foo&#x27;, &#x27;bar&#x27;, Symbol(baz), Symbol(bing)] 其他Api参见 CDN-Reflect 实例：使用Proxy和Reflect实现观察者模式1234567891011121314// 观察目标const person = observable(&#123; name: &#x27;张三&#x27;, age: 20&#125;);// 观察者function print() &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = &#x27;李四&#x27;;// 输出// 李四, 20 实现： 12345678910const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/ES6/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"}]},{"title":"Proxy概述及应用","slug":"blog13","date":"2023-02-13T16:00:00.000Z","updated":"2023-07-08T07:32:07.354Z","comments":false,"path":"2023/02/14/blog13/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/02/14/blog13/","excerpt":"","text":"1.proxy概述用于在修改某些操作的默认行为，可理解为在目标之前架设一层拦截器，外界所有的访问都要通过该拦截器，可以对访问做出过滤和改写。 1234567891011121314151617181920var proxy = new Proxy(target, handler);// target:拦截对象 handler:对象，定义拦截行为var obj = new Proxy(&#123;&#125;, &#123; get: function (target, propKey, receiver) &#123; console.log(`getting $&#123;propKey&#125;!`); return Reflect.get(target, propKey, receiver); &#125;, set: function (target, propKey, value, receiver) &#123; console.log(`setting $&#123;propKey&#125;!`); return Reflect.set(target, propKey, value, receiver); &#125;&#125;);obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 2.proxy拦截操作 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 3.proxy常用实例方法 get():用于拦截某个属性的读取操作，可接受三个参数。目标对象、属性名、proxy实例本身(可选) 12345678910111213141516var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, propKey) &#123; if (propKey in target) &#123; return target[propKey]; &#125; else &#123; throw new ReferenceError(&quot;Prop name \\&quot;&quot; + propKey + &quot;\\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误 set():用来拦截某个属性的赋值操作，接收四个参数。目标对象、属性名、属性值、proxy实例本身(可选) 12345678910111213141516171819202122let validator = &#123; set: function(obj, prop, value) &#123; if (prop === &#x27;age&#x27;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&#x27;The age is not an integer&#x27;); &#125; if (value &gt; 200) &#123; throw new RangeError(&#x27;The age seems invalid&#x27;); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; return true; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = &#x27;young&#x27; // 报错person.age = 300 // 报错 3.apply():拦截函数的调用、call、apply操作，接收三个参数。目标对象、目标对象的上下文对象、目标对象的参数数组。 123456789101112var twice = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments) * 2; &#125;&#125;;function sum (left, right) &#123; return left + right;&#125;;var proxy = new Proxy(sum, twice);proxy(1, 2) // 6proxy.call(null, 5, 6) // 22proxy.apply(null, [7, 8]) // 30 has():拦截HasProperty操作，判断对象是否有某个属性，即in运算符，接收两个参数。目标对象、需查询属性名。has对for in遍历不拦截。 1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === &#x27;_&#x27;) &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: &#x27;foo&#x27;, prop: &#x27;foo&#x27; &#125;;var proxy = new Proxy(target, handler);&#x27;_prop&#x27; in proxy // false construct():用于拦截new命令，接收三个参数。目标对象、构造函数的参数数组、创造实例参数时，new命令作用的构造函数。注意，construct必须返回一个对象，否则会报错。 123456789101112131415161718const p = new Proxy(function () &#123;&#125;, &#123; construct: function(target, args) &#123; console.log(&#x27;called: &#x27; + args.join(&#x27;, &#x27;)); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);// p即为第三个参数(new p(1)).valueconst handler = &#123; construct: function(target, args) &#123; console.log(this === handler); // this指向proxy配置的拦截对象 return new target(...args); &#125;&#125;let p = new Proxy(function () &#123;&#125;, handler);new p() // true deleteProperty():用于拦截delete操作，接收两个参数。目标对象、删除key值。如果方法抛出错误或者返回false说明当前属性无法被delete删除。 1234567891011121314151617var handler = &#123; deleteProperty (target, key) &#123; invariant(key, &#x27;delete&#x27;); delete target[key]; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === &#x27;_&#x27;) &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`); &#125;&#125;var target = &#123; _prop: &#x27;foo&#x27; &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: Invalid attempt to delete private &quot;_prop&quot; property","categories":[{"name":"ES6","slug":"ES6","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/ES6/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"}]},{"title":"Generator函数及Async/Await","slug":"blog11","date":"2023-02-12T16:00:00.000Z","updated":"2023-07-08T07:32:07.354Z","comments":false,"path":"2023/02/13/blog11/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2023/02/13/blog11/","excerpt":"","text":"1.Generator函数Generator函数是ES6中提供的一种异步编程解决方法。Generator是一个状态机，可以依次遍历函数内部的没一个状态。简单可以理解为一个可暂停执行的函数，yield就是暂停标志。 function后面有”*” 函数内部有yield表达式 123456functon * call()&#123; console.log(1) yield &#x27;1&#x27; consol.log(2) yield &#x27;2&#x27;&#125; 2.Generator函数执行机制使用generator函数和使用普通函数一样，在后面加上()就可以了,但是函数并不会马上执行，而是返回一个指向内部函数的指针，调用遍历器对象Iterator的next方法，会分步执行generator函数中的对应逻辑 123456789let f = callf.next() //console =&gt; 1//yield =&gt; &#123;value: &#x27;1&#x27;, done: false&#125; f.next() //console =&gt; 2//yield =&gt; &#123;value: &#x27;2&#x27;, done: false&#125; f.next()//yield =&gt; &#123;value: undefined, done: true&#125; 3.next方法next函数不传入参数时yield表达式返回值是undefined，当next传入参数的时候参数会作为上一步yield的返回值 1234567891011121314151617181920functon * call2()&#123; console.log(&#x27;开始&#x27;) const a = yield 1 consol.log(a) const b = yield 2 console.log(b)&#125;const f2 = call2()f2.next()//console =&gt; &#x27;开始&#x27;f2.next(10)//console =&gt; (10)//yield =&gt; &#123;value: 1, done: false&#125;f2.next(20)//console =&gt; (20)//yield =&gt; &#123;value: 2, done: false&#125;f2.next()//yield =&gt; &#123;value: undefined, done: true&#125; 4.return方法return返回给定值并结束遍历Generator函数。return有参数返回参数没参数返回undefined。 12345678910111213141516171819functon * call3()&#123; console.log(&#x27;开始&#x27;) const a = yield 1 consol.log(a) const b = yield 2 console.log(b)&#125;const f3 = call3()f3.next()//console =&gt; &#x27;开始&#x27;f3.next(10)//console =&gt; (10)//yield =&gt; &#123;value: 1, done: false&#125;f3.return(&quot;end&quot;)//yield =&gt; &#123;value: &quot;end&quot;, done: true&#125;f3.next()//yield =&gt; &#123;value: undefined, done: true&#125; 5.*yield*yield表示yield返回另一个Generator对象,可以在Generator内部调用另一个Generator函数。 123456789101112function* callA() &#123; console.log(&quot;callA: &quot; + (yield))&#125;function* callerB() &#123; while (true) &#123; yield* callA(); &#125;&#125;const callerObj = callerB()callerObj.next()callerObj.next(&quot;first&quot;) // console =&gt; callA :firstcallerObj.next(&quot;second&quot;) // console =&gt; callA :second 6.async/awaitES7中引入，可以理解为Generator的语法糖，对Generator函数进行了修改。await等待的是一个隐式返回Promise作为结果的函数。async、await等同于一个generator+自动执行器 123456789101112131415161718192021222324252627282930313233343536373839404142434445function fn(nums) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(nums * 2) &#125;, 1000) &#125;)&#125;function* gen() &#123; const num1 = yield fn(1) console.log(num1) // 2 const num2 = yield fn(num1) console.log(num2) // 4 const num3 = yield fn(num2) console.log(num3) // 8 return num3&#125;function generatorToAsync(generatorFn) &#123; return function() &#123; const gen = generatorFn.apply(this, arguments) // gen有可能传参 // 返回一个Promise return new Promise((resolve, reject) =&gt; &#123; function go(key, arg) &#123; let res try &#123; res = gen[key](arg) // 这里有可能会执行返回reject状态的Promise &#125; catch (error) &#123; return reject(error) // 报错的话会走catch，直接reject &#125; // 解构获得value和done const &#123; value, done &#125; = res if (done) &#123; // 如果done为true，说明走完了，进行resolve(value) return resolve(value) &#125; else &#123; // 如果done为false，说明没走完，还得继续走 // value有可能是：常量，Promise，Promise有可能是成功或者失败 return Promise.resolve(value).then(val =&gt; go(&#x27;next&#x27;, val), err =&gt; go(&#x27;throw&#x27;, err)) &#125; &#125; go(&quot;next&quot;) // 第一次执行 &#125;) &#125;&#125;const asyncFn = generatorToAsync(gen)asyncFn().then(res =&gt; console.log(res))","categories":[{"name":"ES6","slug":"ES6","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/ES6/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"}]},{"title":"一行代码-网站变灰","slug":"blog10","date":"2022-11-30T16:00:00.000Z","updated":"2023-07-08T07:32:07.354Z","comments":false,"path":"2022/12/01/blog10/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2022/12/01/blog10/","excerpt":"","text":"功能实现 在出现一些突发情况下需要快速将web端页面变灰的需求的时候，仅用一个属性即可让整个项目实现： 1filter: grayscale(1) // 参数为0-1的数值 在body内联样式添加如下代码实现全站变灰 1&lt;body style=&quot;filter:grayscale(1);-webkit-filter:grayscale(1)&quot;&gt;&lt;/body&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/CSS/"}],"tags":[{"name":"样式","slug":"样式","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E6%A0%B7%E5%BC%8F/"}]},{"title":"commitlint+husky+commitizen+lint-stage代码风格及上传规范管理","slug":"blog9","date":"2022-11-07T16:00:00.000Z","updated":"2023-07-08T07:32:07.355Z","comments":false,"path":"2022/11/08/blog9/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2022/11/08/blog9/","excerpt":"","text":"紧接上文说到vite+vue3代码风格及格式化操作，前文主要针对本地化配置格式化。为了更加规范仓库代码，本文引入介绍commitlint等工具，在代码commit的时候再次校验为代码规范再上一层保障。 安装commitlint及commitlint配置包1npm install @commitlint/cli @commitlint/config-conventional -D 添加@commitlint/config-conventional包的目的是使用基础配置，另外也可根据实际需要添加配置文件。例如：commitlint.config.js、.commitlintrc.js、.commitlintrc、.commitlintrc.json、.commitlintrc.yml或package.json中的commit配置 安装husky12345#使用下述命令会在根目录下自动生成.husky文件夹，并创建一个pre-commit钩子实例npx husky-init &amp;&amp; npm install # npmnpx husky-init &amp;&amp; yarn # Yarn 1yarn dlx husky-init --yarn2 &amp;&amp; yarn # Yarn 2+pnpm dlx husky-init &amp;&amp; pnpm install # pnpm 还可以使用如下方式安装husky： 1234npm install husky --save-dev #安装依赖npx --no-install husky install #创建.husky目录(使用--no-install的目的是让npx强制使用node_modules目录下的husky依赖包)npm pkg set scripts.prepare=&quot;husky install&quot; #在package.json中添加初始化命令(此步骤可以省略，但是如果是多人开发会很有必要，初始化仓库可以执行该命令)npx --no-instal husky add .husky/pre-commit &quot;npm run lint&quot; #快速创建pre-commit钩子 添加commit-msg hook（该hook会在commitlint未通过时提示相关信息） 1npx husky add .husky/commit-msg &#x27;npx --no -- commitlint --edit $&#123;1&#125;&#x27; 如何判断上述步骤是否成功可以使用简单的test命令测试 1npx commitlint --from HEAD~1 --to HEAD --verbose 执行commit之后如果出现类似的信息即可认为配置成功 12345678910git commit -m &quot;foo: this will fail&quot;husky &gt; commit-msg (node v10.1.0)No staged files match any of provided globs.⧗ input: foo: this will fail✖ type must be one of [build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test] [type-enum]✖ found 1 problems, 0 warningsⓘ Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlinthusky &gt; commit-msg hook failed (add --no-verify to bypass) 添加commitizencommitizen工具可以通过交互式撰写符合Commit Message规范的Commit Message 123npm install commitizen -D#oryarn add commitizen -D 执行如下命令生成符合Angular的Commit message格式提交规范（使用其他规范可以跳过此步骤） 1npx --no-install commitizen init cz-conventional-changelog --save-dev --save-exact !!!若使用上述命令，需要在package.json中配置一下commitizen适配器 123456789&#123; ... &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot; &#125; &#125; ...&#125; 另外在package.json中的scripts中添加commit脚本替代git commit 123456...&quot;scripts&quot;: &#123; &quot;cz&quot;: &quot;git add . &amp;&amp; git-cz&quot;, &quot;prepare&quot;: &quot;husky install&quot; &#125;... 执行完上述操作就可以使用脚本提交代码 配置commitlint在根目录下新建文件.commitlintrc.js： 12345678910111213141516// 具体配置可参考https://commitlint.js.org/#/reference-rules自行配置不做详细说明module.exports = &#123; ignores: [(commit) =&gt; commit.includes(&#x27;init&#x27;)], extends: [&#x27;@commitlint/config-conventional&#x27;], rules: &#123; &#x27;header-max-length&#x27;: [2, &#x27;always&#x27;, 72], &#x27;scope-case&#x27;: [2, &#x27;always&#x27;, &#x27;lowerCase&#x27;], &#x27;subject-empty&#x27;: [2, &#x27;never&#x27;], &#x27;subject-case&#x27;: [2, &#x27;always&#x27;, [&#x27;lower-case&#x27;, &#x27;sentence-case&#x27;, &#x27;start-case&#x27;, &#x27;pascal-case&#x27;, &#x27;upper-case&#x27;]], &#x27;subject-full-stop&#x27;: [2, &#x27;never&#x27;, &#x27;.&#x27;], &#x27;type-empty&#x27;: [2, &#x27;never&#x27;], &#x27;type-case&#x27;: [2, &#x27;always&#x27;, &#x27;lowerCase&#x27;], &#x27;type-enum&#x27;: [2, &#x27;always&#x27;, [&#x27;feat&#x27;, &#x27;fix&#x27;, &#x27;docs&#x27;, &#x27;style&#x27;, &#x27;perf&#x27;, &#x27;chore&#x27;, &#x27;build&#x27;]] ] &#125;&#125; commitizen输出汉化安装commitlint-config-cz插件配置commit message 1234567npm install commitlint-config-cz -D #cz配置插件#oryarn add commitlint-config-cz -D #cz配置插件#andnpm install cz-customizable -D #cz适配器插件#oryarn add cz-customizable -D #cz适配器插件 在项目根目录下新建.cz-config.js文件 123456789101112131415161718// 配置文件可参考https://github.com/leoforfree/cz-customizable/blob/HEAD/cz-config-EXAMPLE.js自行配置不做详细说明module.exports = &#123; types: [ &#123; value: &#x27;:sparkles: feat&#x27;, name: &#x27;✨ feat: 一项新功能&#x27; &#125;, &#123; value: &#x27;:bug: fix&#x27;, name: &#x27;🐛 fix: 修复一个Bug&#x27; &#125;, &#123; value: &#x27;:memo: docs&#x27;, name: &#x27;📝 docs: 文档变更&#x27; &#125;, &#123; value: &#x27;:lipstick: style&#x27;, name: &#x27;💄 style: 代码风格，格式修复&#x27; &#125;, &#123; value: &#x27;:zap: perf&#x27;, name: &#x27;⚡️ perf: 代码优化,改善性能&#x27; &#125;, &#123; value: &#x27;:rocket: chore&#x27;, name: &#x27;🚀 chore: 变更构建流程或辅助工具&#x27; &#125;, &#123; value: &#x27;:package: build&#x27;, name: &#x27;📦️ build: 变更项目构建或外部依赖&#x27; &#125; ], messages: &#123; type: &#x27;请选择提交类型(必填):&#x27;, subject: &#x27;请简要描述提交(必填):&#x27;, confirmCommit: &#x27;确定提交此说明吗？&#x27; &#125;, skipQuestions: [&#x27;scope&#x27;, &#x27;body&#x27;, &#x27;breaking&#x27;, &#x27;footer&#x27;]&#125; 创建完.cz-config.js 返回package.json修改commitizen适配器选项1234567...&quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;node_modules/cz-customizable&quot; &#125;&#125;,... 若之前使用Angular的Commit message格式提交规范，需修改.commitlintrc.js文件，节约空间可以卸载掉@commitlint/config-conventional插件（用不上了）12345module.exports = &#123; ... extends: [], ...&#125; 集成 gitmoji123npm install commitlint-config-gitmoji -D#oryarn add commitlint-config-gitmoji -D 修改.commitlintrc.js12345module.exports = &#123; ... extends: [&#x27;gitmoji&#x27;], ...&#125; 使用gitmoji的时候可能会遇到如下问题： 报错找不到gitmojis.json 两种解决方案：在node_modules/commitlint-plugin-gitmoji/lib下添加gitmojis.json 在根目录下添加gitmojis.json并修改.cz-config.js 1234567891011121314 process.env.GITMOJI_PATH = &#x27;.gitmoji.json&#x27; modules.exports=&#123; ... &#125;``` 2. 偶遇校验不通过需要严格按照上述事例配置.commitlintrc.js（列出来的rule勿改）### 安装lint-stage文件过滤器，每次只校验commit的文件```shellnpm install lint-staged -D#oryarn add lint-stage -D 修改.husky/pre-commit 1234#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npx lint-staged 修改package.json 12345678910111213// 具体使用可参考lint-stage介绍：https://github.com/okonet/lint-staged#readme...&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,jsx,ts,tsx&#125;&quot;: [ &quot;eslint --fix&quot;, //eslint校验 &quot;prettier --write&quot; //prettier格式化 ], &quot;*.vue&quot;: [ &quot;eslint --fix&quot;, &quot;prettier --write&quot; ]&#125;... 有关eslint及prettier的问题可以参见上篇文章。vite+vue3代码风格校验及格式化 以上就是本文全部内容，由于项目成本关系没有引入其他工具，像文件校验，commit-log自动添加，stylelint等，有兴趣的朋友可以自行尝试。 附录gitmojis.json文件地址","categories":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"prettier+eslint+commitlint项目实践","slug":"blog8","date":"2022-10-28T00:00:00.000Z","updated":"2022-11-27T04:13:15.827Z","comments":false,"path":"2022/10/28/blog8/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2022/10/28/blog8/","excerpt":"","text":"团队代码风格统一一直是博主想干又没有时间去干的事情，刚好借着新项目搭建，尝试一下使用Eslint及Prettier工具提升一下项目代码的整体质量。本文在配置方面仅做简单的配置，流程熟悉可以参考Eslint及Prettier官方文档定制自己喜欢的标准。 安装Eslint包1npm install eslint -D 初始化Eslint1npm init @eslint/config 执行命令后会出现以下选项：（可以按照图片配置，也可以后面直接更改.eslintrc.cjs文件）具体配置可以以自己项目为准，博主这里使用的是vite+vue3+js安装完成之后项目的根目录会出现.eslintrc.cjs文件 12345678910111213141516171819202122module.exports = &#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;es2021&quot;: true, &quot;node&quot;: true &#125;, &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:vue/vue3-essential&quot; ], &quot;overrides&quot;: [ ], &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: &quot;latest&quot;, &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;plugins&quot;: [ &quot;vue&quot; ], &quot;rules&quot;: &#123; &#125;&#125; 安装vite-plugin-eslint包12// 该包的作用是在vite运行时自动检测eslint规范，根据配置在终端显示未通过的校验代码npm install vite-plugin-eslint -D 安装eslint-parser 及 @babel/core 包123// 该包的作用是允许eslint在babel转换的源代码上运行npm install @babel/eslint-parser -Dnpm install @babel/core -D 安装prettier相关包123npm install prettier -Dnpm install eslint-config-prettier -D // eslint兼容的插件,将关闭eslint所有不必要或可能与Prettier冲突的规则npm install eslint-plugin-prettier -D // eslint的prettier,将Prettier作为ESLint规则运行，并将差异作为单个ESLint问题报告。 安装vue-eslint-parser包12// 用于`.vue`文件的ESLint自定义解析器。npm install vue-eslint-parser -D 配置.prettierrc12345678910111213// .prettierrc, 配置不做过多说明，具体可查阅相关文档&#123; &quot;printWidth&quot;: 120, &quot;tabWidth&quot;: 2, &quot;useTabs&quot;: false, &quot;semi&quot;: false, &quot;trailingComma&quot;: &quot;none&quot;, &quot;singleQuote&quot;: true, &quot;bracketSpacing&quot;: true, &quot;jsxBracketSameLine&quot;: false, &quot;endOfLine&quot;: &quot;auto&quot;, &quot;arrowParens&quot;: &quot;avoid&quot;&#125; 配置.eslintrc.cjs1234567891011121314151617181920212223242526272829303132333435363738module.exports = &#123; env: &#123; browser: true, es2021: true, node: true &#125;, extends: [ &#x27;eslint:recommended&#x27;, // eslint核心规则 &#x27;plugin:vue/vue3-essential&#x27;, // 继承eslint-plugin-vue组件中的基础配置 &#x27;plugin:prettier/recommended&#x27;, // 继承eslint-plugin-prettier组件中的基础配置 &#x27;eslint-config-prettier&#x27; // 处理配置兼容问题 ], parser: &#x27;vue-eslint-parser&#x27;, // 使用vue解析器 parserOptions: &#123; // 设置支持的JavaScript语言选项 ecmaVersion: &#x27;latest&#x27;, // 指定EcmaScript的版本 sourceType: &#x27;module&#x27;, // script/module ecmaFeatures: &#123; jsx: true &#125; &#125;, plugins:[ &#x27;vue&#x27;, // eslint-plugin-vue缩写 &#x27;prettier&#x27; // eslint-plugin-prettier缩写 ], globals: &#123; // 添加全局变量，防止no-undef 规则发出警告 defineProps: &#x27;readonly&#x27;, defineEmits: &#x27;readonly&#x27;, defineExpose: &#x27;readonly&#x27;, withDefaults: &#x27;readonly&#x27; &#125;, rules: &#123; &#x27;no-console&#x27;: &#x27;warn&#x27;, &#x27;vue/multi-word-component-names&#x27;: &#x27;off&#x27; // extends中继承过来的属性，可以重新修改 ... &#125;&#125; VSCode配置安装ESLint及Prettier插件 打开VSCode设置&gt;用户&gt;文本编辑器&gt;格式化&gt;勾选Format On Save 2. 搜索Prettier&gt;勾选Require Config3.打开VSCode设置&gt;用户&gt;文本编辑器&gt;Default Formatter&gt;选择Prettier - Code formatter4.ctr+shift+p打开首选项配置settings.json&gt;添加eslint vue支持 1234567...&quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;vue&quot; ],... 特别提醒：每次修改完Eslint及Prettier配置最好重新启动VSCode，防止出现配置不生效的情况","categories":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"Element组件MessageBox剖析","slug":"blog7","date":"2022-10-10T00:00:00.000Z","updated":"2022-10-10T11:00:56.172Z","comments":false,"path":"2022/10/10/blog7/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2022/10/10/blog7/","excerpt":"","text":"因最近业务需求需要实现类似于Element中的MessageBox组件的效果，所以尝试封装了一个类似的小组件，本文不介绍封装，因为受到MessageBox的启发，所以通过源码注释的方式详细剖析一下Element的MessageBox实现思想。 基础知识Vue.extend(options) 参数：{Object} options 用法：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。需要注意的是：data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 1&lt;div id=&quot;mount-point&quot;&gt;&lt;/div&gt; 12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: &#x27;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#x27;, data: function () &#123; return &#123; firstName: &#x27;Walter&#x27;, lastName: &#x27;White&#x27;, alias: &#x27;Heisenberg&#x27; &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount(&#x27;#mount-point&#x27;) 结果： 1&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; 为什么要介绍Vue.extend(options)，因为Element中MessageBox的使用方式为函数式调用 （this.$confirm()）的形式，以这种形式调用组件就不能按照常规的组件引入注册的形式去调用，可以通过Vue.extend(options)创建一个vue子类再通过函数暴露出去的方式实现函数式调用。 Element MessageBox 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// main.js 仅介绍主要部分代码...import Vue from &#x27;vue&#x27;;// 引入模板文件import msgboxVue from &#x27;./main.vue&#x27;; // element合并对象的工具函数，代码比较简单可以自行查阅import merge from &#x27;element-ui/src/utils/merge&#x27;; import &#123; isVNode &#125; from &#x27;element-ui/src/utils/vdom&#x27;;// 创建一个新的vue构造器，构造器可以手动挂载到一个新的Dom上const MessageBoxConstructor = Vue.extend(msgboxVue);let currentMsg, instance;let msgQueue = [];// 创建一个新的vue子实例const initInstance = () =&gt; &#123; instance = new MessageBoxConstructor(&#123; el: document.createElement(&#x27;div&#x27;) &#125;); // 给实例添加callback对象，后面会分析到 instance.callback = defaultCallback;&#125;;// defaultCallback处理了两种形式的回调方式// 1.可以手动传入一个callback函数// 2.使用默认的promise方式const defaultCallback = action =&gt; &#123; if (currentMsg) &#123; let callback = currentMsg.callback; // 处理传入回调函数情况 if (typeof callback === &#x27;function&#x27;) &#123; // showInput区分是否为输入框MessageBox if (instance.showInput) &#123; callback(instance.inputValue, action); &#125; else &#123; callback(action, instance); &#125; &#125; // 处理promise情况 if (currentMsg.resolve) &#123; if (action === &#x27;confirm&#x27;) &#123; if (instance.showInput) &#123; currentMsg.resolve(&#123; value: instance.inputValue, action &#125;); &#125; else &#123; currentMsg.resolve(action); &#125; &#125; else if (currentMsg.reject &amp;&amp; (action === &#x27;cancel&#x27; || action === &#x27;close&#x27;)) &#123; currentMsg.reject(action); &#125; &#125; &#125;&#125;;const showNextMsg = () =&gt; &#123; if (!instance) &#123; initInstance(); &#125; instance.action = &#x27;&#x27;; if (!instance.visible || instance.closeTimer) &#123; if (msgQueue.length &gt; 0) &#123; // 顺序执行msgQueue中的currentMsg currentMsg = msgQueue.shift(); // currentMsg内容如下: // &#123; // options: merge(&#123;&#125;, defaults, MessageBox.defaults, options), // callback: callback, // resolve: resolve, // reject: reject // &#125; let options = currentMsg.options; // 将参数挂载到新创建的实例data上 for (let prop in options) &#123; if (options.hasOwnProperty(prop)) &#123; // 实例参数修改 instance[prop] = options[prop]; &#125; &#125; // 如果options没传入callback将默认的callback赋值给实例的callback if (options.callback === undefined) &#123; // 当options里面有callback传入，正常输出。 // 当options里面没有callback,instance.callback使用defaultCallback instance.callback = defaultCallback; &#125; // 再次封装callback let oldCb = instance.callback; instance.callback = (action, instance) =&gt; &#123; oldCb(action, instance); showNextMsg(); &#125;; // 判断message是否传入的是Html片段,如果是Html片段添加到slot if (isVNode(instance.message)) &#123; instance.$slots.default = [instance.message]; instance.message = null; &#125; else &#123; delete instance.$slots.default; &#125; // 将某些特定的参数设定初始值 [&#x27;modal&#x27;, &#x27;showClose&#x27;, &#x27;closeOnClickModal&#x27;, &#x27;closeOnPressEscape&#x27;, &#x27;closeOnHashChange&#x27;].forEach(prop =&gt; &#123; if (instance[prop] === undefined) &#123; instance[prop] = true; &#125; &#125;); // 注意message是挂载到body上 document.body.appendChild(instance.$el); // 控制弹窗出现 Vue.nextTick(() =&gt; &#123; instance.visible = true; &#125;); &#125; &#125;&#125;;const MessageBox = function(options, callback) &#123; if (Vue.prototype.$isServer) return; if (typeof options === &#x27;string&#x27; || isVNode(options)) &#123; // 当options参数为字符串 this.$msgbox(&#x27;xxx&#x27;)情况下默认设置message字段 options = &#123; message: options &#125;; // 若有两个及以上参数判断第二个参数是否为字符串赋值给title if (typeof arguments[1] === &#x27;string&#x27;) &#123; options.title = arguments[1]; &#125; &#125; else if (options.callback &amp;&amp; !callback) &#123; // 参数为对象且对象有callback字段时 将callback赋值给callback callback = options.callback; &#125; // 兼容不支持Promise情况 if (typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise((resolve, reject) =&gt; &#123; // eslint-disable-line msgQueue.push(&#123; options: merge(&#123;&#125;, defaults, MessageBox.defaults, options), callback: callback, resolve: resolve, reject: reject &#125;); showNextMsg(); &#125;); &#125; else &#123; msgQueue.push(&#123; options: merge(&#123;&#125;, defaults, MessageBox.defaults, options), callback: callback &#125;); showNextMsg(); &#125;&#125;; // 使用方式1: // this.$msgbox(&#123;title:&#x27;测试&#x27;,message:&#x27;测试&#x27;,callback:(action,instance)=&gt;&#123; // console.log(action) //confirm // console.log(instance) //vue实例 // &#125;&#125;) // 使用方式2: // this.$msgbox(&#123;title:&#x27;测试&#x27;,message:&#x27;测试&#x27;&#125;,(action,instance)=&gt;&#123; // console.log(action) //confirm // console.log(instance) //undefined // &#125;)...// 暴露MessageBox方法export default MessageBox;export &#123; MessageBox &#125;; 可以看出Message组件主要的两个方法一个是MessageBox，一个是showNextMsg，这两个方法的主要功能一个是添加新的message对象一个是设置实例参数，除了callback的理解有些复杂外其他的代码理解应该不难。至于main.vue文件就是普通的vue文件不再赘述。 简单实现MessageBox组件源码","categories":[{"name":"组件","slug":"组件","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"Element","slug":"Element","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/Element/"}]},{"title":"Linux常见命令总结","slug":"blog6","date":"2022-08-26T16:00:00.000Z","updated":"2022-08-27T09:43:39.955Z","comments":false,"path":"2022/08/27/blog6/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2022/08/27/blog6/","excerpt":"","text":"总结一下常见Linux操作命令，以备不时之需 目录与文件相关1234567891011pwd //显示当前工作目录mkdir &#x27;dir&#x27; //创建工作目录rmdir &#x27;dir&#x27; //删除工作目录cd &#x27;dir&#x27; //进入文件夹cd .. //返回上层目录touch &#x27;file&#x27; //创建文件rm -rf &#x27;file/dir&#x27; //删除文件或目录ls //列出所有文件和目录ls -a //查看所有文件(包括隐藏文件)ls -l //详细显示ls -m //逗号分隔显示 文件内容显示12cat &gt; &#x27;file&#x27; //创建文件并编辑内容（ctr+D结束编辑）cat -n &#x27;file&#x27; //查看文件 vi编辑器12345vi [path/file] //打开编辑器i //进入编辑模式esc //进入命令模式:wq //保存并推出:q! //退出不保存 其他命令1234clear //清除屏幕信息date //显示当前日期ps //查看所有进程last //显示最近登陆系统用户信息","categories":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/Linux/"}]},{"title":"H5在IOS微信webview中无法校验视频时长问题","slug":"blog5","date":"2022-07-30T16:00:00.000Z","updated":"2022-07-31T11:56:48.542Z","comments":false,"path":"2022/07/31/blog5/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2022/07/31/blog5/","excerpt":"","text":"因业务需求需要一个图片视频文件上传功能，需支持主流浏览器及微信钉钉内置浏览器，遂考虑用一个简单的H5页面做上传客户端。视频上传因为要控制视频长度，在其他浏览器中都校验通过，但是在微信中却出了问题 123456789101112131415161718192021222324const beforeRead = (file)=&gt; &#123; return new Promise((resolve,reject)=&gt;&#123; if(props.type == &#x27;video&#x27;)&#123; let url = URL.createObjectURL(file) let audioElement = new Audio(url) audioElement.addEventListener(&quot;loadedmetadata&quot;, ()=&gt;&#123; let audioDuration = audioElement.duration; if(audioDuration&gt;60)&#123; Toast(`仅支持上传1分钟时长以内视频`) reject() &#125;else&#123; resolve(file) &#125; &#125;) &#125;else&#123; if (![&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;].includes(file.type)) &#123; Toast(&#x27;所选文件格式不支持&#x27;); reject() &#125;else&#123; resolve(file) &#125; &#125; &#125;) &#125; 问题原因：IOS微信浏览器需要播放视频才能通过监听loadedmetadata事件获取视频长度，以下是解决办法： 12345678910111213141516171819202122232425262728const beforeRead = (file)=&gt; &#123; return new Promise((resolve,reject)=&gt;&#123; if(props.type == &#x27;video&#x27;)&#123; let url = URL.createObjectURL(file) let audioElement = new Audio(url) audioElement.muted = true audioElement.play().then(()=&gt;audioElement.pause()) audioElement.addEventListener(&quot;loadedmetadata&quot;, ()=&gt;&#123; let audioDuration = audioElement.duration; if(audioDuration&gt;60)&#123; audioElement.muted = false Toast(`仅支持上传1分钟时长以内视频`) reject() &#125;else&#123; audioElement.muted = false resolve(file) &#125; &#125;) &#125;else&#123; if (![&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;].includes(file.type)) &#123; Toast(&#x27;所选文件格式不支持&#x27;); reject() &#125;else&#123; resolve(file) &#125; &#125; &#125;) &#125; H5页面vue3.0+vant，参见upload组件不再赘述！","categories":[{"name":"vue","slug":"vue","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/vue/"}],"tags":[{"name":"vue-3","slug":"vue-3","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/vue-3/"}]},{"title":"Taro小程序添加Echarts代码包过大解决办法","slug":"blog4","date":"2021-10-19T00:00:00.000Z","updated":"2022-10-10T11:00:56.172Z","comments":false,"path":"2021/10/19/blog4/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2021/10/19/blog4/","excerpt":"","text":"上回书说到如何在Taro小程序中引入Echarts图表。如果小程序主包代码体量不多可以直接使用，但是如果小程序代码体量大，稍不留神就会导致主包代码超过2M，无法预览也无法真机调试。本文着重介绍一下Taro引入Echarts分包操作以及注意事项。 前文链接，完整流程可以自行查阅 taro小程序添加Echarts实践分包操作： 将与echarts组件相关都移到分包中，结构目录如下 配置app.config.js 12345678910...subpackages: [ &#123; root: &quot;subpages&quot;, pages: [ &#x27;test/index&#x27; ] &#125; ],... 配置config/index 导致包文件过大的“罪魁祸首”就是ec-canvas文件夹下的echarts.js文件。所以我们需要解决的问题是，分包使用Echarts组件不能将echarts.js打包到主包的common.js里面。Taro机制认为一个js文件被多个模块依赖会将该js抽离到common.js。虽然我们关于Echarts相关的文件都放在subpages里面，但是如果引用多次还是会抽离到主包common.js。所以我们需要使用splitChunks将Echarts部分单独打包，然后使用addChunkPages 往页面注入依赖。 12345678910111213141516171819202122232425262728293031// config/index.jsmini: &#123; compile: &#123; exclude: [ // 跳过编译 path.resolve(__dirname, &#x27;..&#x27;, &#x27;src/subpages/components/ec-canvas/echarts.js&#x27;) ] &#125;, addChunkPages (pages) &#123; pages.set(&#x27;subpages/test/index&#x27;, [&#x27;subpages/common&#x27;]) &#125;, webpackChain (chain) &#123; chain.merge(&#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; subpackagesCommon: &#123; name: &#x27;subpages/common&#x27;, minChunks: 2, test: (module,chunks) =&gt; &#123; const isNoOnlySubpackRequired = chunks.find(chunk =&gt; !(/\\bsubpages\\b/.test(chunk.name))) return !isNoOnlySubpackRequired &#125;, priority: 200 &#125; &#125; &#125; &#125; &#125;) &#125; &#125; 至此可以看到打包效果： 页面引用参考前文页面使用。此时如果我们运行代码，可能会发现一个问题：注意这个错误！提示找不到ec-canvas组件。注意编译后的组件ec-canvas.js因为之前抽离了echarts.js，现在已经无法引入，所以需要在编译后的文件中引入subpages里面的common.js。 添加引入plugin(代码很简单，可以先学习一下官方文档如何编写一个插件) 123456789101112131415161718/* eslint-disable import/no-commonjs *//* 解决chunk包没有引用资源的问题**/const fs = require(&#x27;fs&#x27;);const path = require(&quot;path&quot;);module.exports.default = module.exports = (ctx, options) =&gt; &#123; ctx.onBuildFinish(() =&gt; &#123; const chunkRequireArray = options.chunkRequireArray for(let i in chunkRequireArray)&#123; const unitData = chunkRequireArray[i]; const target = path.join(ctx.paths.outputPath, unitData.fileDistPath); const data = fs.readFileSync(target, &#x27;utf8&#x27;); fs.writeFileSync(target, `$&#123;unitData.prependContent&#125;;$&#123;data&#125;`) &#125; &#125;)&#125; 配置config/index.js 12345678910111213plugins: [ [ path.resolve(__dirname, &#x27;..&#x27;, &#x27;plugin/chunkCacheRequirePlugin&#x27;), &#123; chunkRequireArray:[ //可配置多个目标引入文件 &#123; fileDistPath: &#x27;subpages/components/ec-canvas/ec-canvas.js&#x27;, prependContent: &#x27;require(&quot;../../common&quot;);&#x27; &#125; ] &#125; ] ], 重新编译就可以了：","categories":[{"name":"taro","slug":"taro","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/taro/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Taro小程序引入Echarts教程","slug":"blog3","date":"2021-10-18T00:00:00.000Z","updated":"2022-07-31T11:43:24.895Z","comments":false,"path":"2021/10/18/blog3/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2021/10/18/blog3/","excerpt":"","text":"小程序需要添加简单的数据统计功能。因为对Echats比较熟悉，所以想将Echats引入到项目中，有几点注意事项，记录一下。 taro版本：3.3.2（注意一下版本信息）,官方物料仓库里面的Echarts大多不兼容最新版本taro框架，但是实现的思路都是一样的。大致说一下： 准备工作 下载Echarts官方的小程序插件echarts-for-weixin 传送门 将项目中的ec-canvas文件夹复制保存 去Echarts官网定制图表(不建议全部下载，文件太大，小程序体积大需要分包) 传送门 压缩echarts.js文件(压缩方法可以自行找线上压缩网站或自行压缩，方法附后文） 替换ec-canvas文件中的echarts.js文件 本地压缩方法 12npm install uglify-js -guglifyjs echarts.js -m -o echarts.min.js //注意：替换ec-canvas里面的文件时将echarts.min.js换回来 小程序封装图表组件(以柱状图为例)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 柱状图import &#123; Component &#125; from &quot;react&quot;;import &#123; View &#125; from &quot;@tarojs/components&quot;;import &#123; getCurrentInstance &#125; from &quot;@tarojs/taro&quot; //Taro3.x需要使用getCurrentInstance 获取页面DOMimport &#x27;./index.scss&#x27;function setChartData(chart)&#123; const defautOption = &#123; xAxis: &#123; type: &quot;category&quot;, data: [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;], &#125;, yAxis: &#123; type: &quot;value&quot;, &#125;, series: [ &#123; data: [120, 200, 150, 80, 70, 110, 130], type: &quot;bar&quot;, showBackground: true, backgroundStyle: &#123; color: &quot;rgba(220, 220, 220, 0.8)&quot;, &#125;, &#125;, ], &#125;; chart.setOption(defautOption);&#125;export default class BarChart extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; ec: &#123; lazyLoad: true &#125; &#125; &#125; componentDidMount() &#123; &#125; refresh(data) &#123; getCurrentInstance().page.selectComponent(&#x27;#mychart-area&#x27;).init((canvas, width, height) =&gt; &#123; const chart = echarts.init(canvas, null, &#123; width: width, height: height &#125;); setChartData(chart, data); return chart; &#125;); &#125; render() &#123; return ( &lt;View className=&#x27;bar-chart&#x27;&gt; &lt;ec-canvas id=&#x27;mychart-area&#x27; canvasId=&#x27;mychart-area&#x27; ec=&#123;this.state.ec&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 页面使用1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from &#x27;react&#x27;import &#123; View &#125; from &#x27;@tarojs/components&#x27;import BarChart from &#x27;@/components/barChart&#x27;import &#x27;./index.scss&#x27;export default class Index extends Component &#123; constructor (props) &#123; super(props) this.barChart = React.createRef() this.state = &#123; &#125; &#125; componentWillMount () &#123; &#125; componentDidMount () &#123; // 延迟调用，确保 ec-canvas 节点已存在 setTimeout(() =&gt; &#123; this.barChart.current.refresh() &#125;, 100) &#125; componentWillUnmount () &#123; &#125; componentDidShow () &#123; &#125; componentDidHide () &#123; &#125; render () &#123; return ( &lt;View className=&#x27;selfstudy-container&#x27;&gt; &lt;BarChart ref=&#123;this.barChart&#125; /&gt; &lt;/View&gt; ) &#125;&#125; ——————————————————至此图表引入已完成90%————————————————————-直接页面使用的话会报两个错误： echarts is not defined。（没有拿到ec-canvas页面实例） 解决方法：在 app 或页面配置文件中配置 usingComponents 属性。 12345678export default &#123; usingComponents: &#123; // 定义需要引入的第三方组件 // 1. key 值指定第三方组件名字，以小写开头 // 2. value 值指定第三方组件 js 文件的相对路径 &#x27;ec-canvas&#x27;: &#x27;../../components/ec-canvas/ec-canvas&#x27; &#125;&#125; 注意：Taro3 的组件是没有配置文件的，因此 usingComponents 必须配置在“页面”的配置文件中。2. t.addEventListener is not a function 解决方法：在 ec-canvas文件夹下面的wx-canvas.js文件添加代码： 123456789101112131415161718192021222324252627export default class WxCanvas &#123; constructor(ctx, canvasId, isNew, canvasNode) &#123; this.ctx = ctx; this.canvasId = canvasId; this.chart = null; this.isNew = isNew if (isNew) &#123; this.canvasNode = canvasNode; &#125; else &#123; this._initStyle(ctx); &#125; // this._initCanvas(zrender, ctx); this._initEvent(); &#125; // 新增空函数，修复调用 echarts.init 时报错 addEventListener () &#123;&#125; getContext(contextType) &#123; if (contextType === &#x27;2d&#x27;) &#123; return this.ctx; &#125; &#125;&#125;","categories":[{"name":"taro","slug":"taro","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/taro/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Taro小程序分享","slug":"blog2","date":"2020-04-03T00:00:00.000Z","updated":"2022-07-31T11:43:24.894Z","comments":false,"path":"2020/04/03/blog2/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2020/04/03/blog2/","excerpt":"","text":"在开发小程序的时候遇到自定义分享按钮分享卡片到好友的需求，由于小程序的分享只有在页面 js 中定义了 onShareAppMessage(Object)方法才会出现右上角的分享按钮,所以需要在页面中自定义分享方法。具体见下： object 参数 onShareAppMessage(Object)事件需要返回一个 Object 对象对象里面包含要分享的标题，转发的路径，以及自定义图片的路径。完成了这一系列操作就可以愉快的去分享微信小程序的页面了。 1234567891011121314151617// 在页面中使用import Taro, &#123; Component &#125; from &quot;@tarojs/taro&quot;;import &#123; View &#125; from &quot;@tarojs/components&quot;;class index extends Component &#123; onShareAppMessage() &#123; return &#123; title: &quot;自定义标题&quot;, path: &quot;/page/user?id=123&quot;, // 自定义的分享路径，点击分享的卡片之后会跳转这里定义的路由 imageUrl: &quot;&quot;, // 图片路径 &#125;; &#125; render() &#123; return &lt;View&gt;微信分享&lt;/View&gt;; &#125;&#125;export default index; 自定义分享按钮事件的实现。有时候，在大多数的业务场景下我们需要在页面中点击某个按钮触发分享的事件，此时需要监听用户点击页面内转发按钮（Button 组件 openType=’share’）就会自动触发 onShareAppMessage 方法。如果需要在 button 中携带信息，需要自定义 button 属性，通过 res.target.dataset 获取。 1234567891011121314151617181920212223242526272829303132// 在页面中使用import Taro, &#123; Component &#125; from &quot;@tarojs/taro&quot;;import &#123; View &#125; from &quot;@tarojs/components&quot;;class index extends Component &#123; onShareAppMessage(res) &#123; if (res.from === &quot;button&quot;) &#123; const &#123; share = &#123;&#125; &#125; = res.target.dataset; return &#123; title: `自定义分享按钮$&#123;share.title&#125;`, path: `/pages/bill/index`, imageUrl: &quot;&quot;, &#125;; &#125; else &#123; return &#123; title: &quot;右上角分享事件&quot;, path: `/pages/bill/index`, imageUrl: &quot;&quot;, &#125;; &#125; &#125; render() &#123; return ( &lt;View&gt; &lt;Button open-type=&quot;share&quot; data-share=&#123;data&#125;&gt; 点击分享 &lt;/Button&gt; &lt;/View&gt; ); &#125;&#125;export default index; 需要注意的是，onShareAppMessage 不支持异步调用，如果有需求是先请求接口的数据再分享会因为拿不到数据导致分享信息不正确的错误。","categories":[{"name":"taro","slug":"taro","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/taro/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"vue 使用高德地图 Api 获取当前经纬度信息","slug":"blog1","date":"2020-04-02T00:00:00.000Z","updated":"2022-07-31T11:43:24.894Z","comments":false,"path":"2020/04/02/blog1/","link":"","permalink":"https://ovyvo.github.io/yanblog.github.io/2020/04/02/blog1/","excerpt":"","text":"在 utils 里面新建 getLocation.js 封装获取经纬度的公用方法(优化加载速度动态 cdn 引入高德地图) 由于高德 Api 方法获取当前经纬度比较慢，如果需求是在获取到当前经纬度数据之后请求一些数据，需要搭配 promise 使用保证获取到经纬度信息。具体见下面代码 1234567891011121314151617181920212223242526272829function loadSDK() &#123; if (window.AMap) return; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement(&quot;script&quot;); script.src = &quot;http://webapi.amap.com/maps?v=1.4.6&amp;key=*****************&quot;; //***为申请的高德key document.head.appendChild(script); script.onload = resolve; script.onerror = reject; &#125;);&#125;export default async () =&gt; &#123; await loadSDK(); return new Promise((resolve) =&gt; &#123; // eslint-disable-next-line no-undef AMap.plugin(&quot;AMap.Geolocation&quot;, () =&gt; &#123; // eslint-disable-next-line no-undef const geolocation = new AMap.Geolocation(&#123; enableHighAccuracy: false &#125;); geolocation.getCurrentPosition((status, result) =&gt; &#123; const res = status === &quot;complete&quot; ? result.position : &#123; lat: 39.909187, lng: 116.397451 &#125;; //默认北京 116.397451、39.909187 console.log(&quot;定位结果&quot;, res); resolve(res); &#125;); &#125;); &#125;);&#125;; 在 vue 页面中的使用（这里假设需求是请求离我最近店铺信息列表） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;main-container&quot;&gt; &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;list-item&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt; //you can do something &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as Api from &#x27;@/api/xxx.js&#x27; //引入请求接口的Apiimport getLocation from &#x27;@/utils/getLocation&#x27; //引入getLocation方法export default &#123; data() &#123; return &#123; params: &#123;&#125;, list: [] &#125; &#125;, mounted() &#123; this.fetchList() &#125;, methods: &#123; async getPosition() &#123; const &#123; lng, lat &#125; = await getLocation() this.params = &#123; lng, lat &#125; &#125;, async fetchList() &#123; await this.getPosition() const &#123; list &#125; = await Api.fetchList(this.params) this.list = list &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&#x27;less&#x27; scoped&gt;&lt;/style&gt; 注意如果在 index.html 中引入高德地图在全局使用 AMap 构造函数需要在 vue.config.js 添加如下配置,否则会报‘AMap is not defined’错误 1234567module.exports = &#123; configureWebpack: &#123; externals: &#123; AMap: &quot;AMap&quot;, &#125;, &#125;,&#125;; 在页面中使用（举个 🌰，代码未测试） 12345678910111213141516171819&lt;script&gt;import AMap from &#x27;AMap&#x27;export default&#123; methods:&#123; fn()&#123; AMap.plugin(&#x27;AMap.Geolocation&#x27;, () =&gt; &#123; const geolocation = new AMap.Geolocation(&#123; enableHighAccuracy: false &#125;) geolocation.getCurrentPosition((status, result) =&gt; &#123; const res = status === &#x27;complete&#x27; ? result.position : &#123; lat: 39.909187, lng: 116.397451 &#125; //默认北京 116.397451、39.909187 console.log(&#x27;定位结果&#x27;, res) &#125;) &#125;) &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/vue/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"组件","slug":"组件","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E7%BB%84%E4%BB%B6/"},{"name":"资源","slug":"资源","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E8%B5%84%E6%BA%90/"},{"name":"性能优化","slug":"性能优化","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/vue/"},{"name":"ES6","slug":"ES6","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/ES6/"},{"name":"CSS","slug":"CSS","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/CSS/"},{"name":"taro","slug":"taro","permalink":"https://ovyvo.github.io/yanblog.github.io/categories/taro/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/nginx/"},{"name":"vue-3","slug":"vue-3","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/vue-3/"},{"name":"AIGC","slug":"AIGC","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/AIGC/"},{"name":"JS","slug":"JS","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/JS/"},{"name":"工具","slug":"工具","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Element","slug":"Element","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/Element/"},{"name":"vue-2","slug":"vue-2","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/vue-2/"},{"name":"样式","slug":"样式","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E6%A0%B7%E5%BC%8F/"},{"name":"代码规范","slug":"代码规范","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"Linux","slug":"Linux","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/Linux/"},{"name":"小程序","slug":"小程序","permalink":"https://ovyvo.github.io/yanblog.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}